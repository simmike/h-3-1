
/** krpano-content/krpano-wrapper-style/js/live/atmosphere.js **/
/*
 * Copyright 2015 Async-IO.org
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Atmosphere.js
 * https://github.com/Atmosphere/atmosphere-javascript
 *
 * API reference
 * https://github.com/Atmosphere/atmosphere/wiki/jQuery.atmosphere.js-API
 *
 * Highly inspired by
 * - Portal by Donghwan Kim http://flowersinthesand.github.io/portal/
 */
(function (root, factory) {
    if (typeof define === "function" && define.amd) {
        // AMD
        define(factory);
    } else if(typeof exports !== 'undefined') {
        // CommonJS
        module.exports = factory();
    } else {
        // Browser globals, Window
        root.atmosphere = factory();
    }
}(this, function () {

    "use strict";

    var atmosphere = {},
        guid,
        offline = false,
        requests = [],
        callbacks = [],
        uuid = 0,
        hasOwn = Object.prototype.hasOwnProperty;

    atmosphere = {
        version: "2.3.3-javascript",
        onError: function (response) {
        },
        onClose: function (response) {
        },
        onOpen: function (response) {
        },
        onReopen: function (response) {
        },
        onMessage: function (response) {
        },
        onReconnect: function (request, response) {
        },
        onMessagePublished: function (response) {
        },
        onTransportFailure: function (errorMessage, _request) {
        },
        onLocalMessage: function (response) {
        },
        onFailureToReconnect: function (request, response) {
        },
        onClientTimeout: function (request) {
        },
        onOpenAfterResume: function (request) {
        },

        /**
         * Creates an object based on an atmosphere subscription that exposes functions defined by the Websocket interface.
         *
         * @class WebsocketApiAdapter
         * @param {Object} request the request object to build the underlying subscription
         * @constructor
         */
        WebsocketApiAdapter: function (request) {
            var _socket, _adapter;

            /**
             * Overrides the onMessage callback in given request.
             *
             * @method onMessage
             * @param {Object} e the event object
             */
            request.onMessage = function (e) {
                _adapter.onmessage({data: e.responseBody});
            };

            /**
             * Overrides the onMessagePublished callback in given request.
             *
             * @method onMessagePublished
             * @param {Object} e the event object
             */
            request.onMessagePublished = function (e) {
                _adapter.onmessage({data: e.responseBody});
            };

            /**
             * Overrides the onOpen callback in given request to proxy the event to the adapter.
             *
             * @method onOpen
             * @param {Object} e the event object
             */
            request.onOpen = function (e) {
                _adapter.onopen(e);
            };

            _adapter = {
                close: function () {
                    _socket.close();
                },

                send: function (data) {
                    _socket.push(data);
                },

                onmessage: function (e) {
                },

                onopen: function (e) {
                },

                onclose: function (e) {
                },

                onerror: function (e) {

                }
            };
            _socket = new atmosphere.subscribe(request);

            return _adapter;
        },

        AtmosphereRequest: function (options) {

            /**
             * {Object} Request parameters.
             *
             * @private
             */
            var _request = {
                timeout: 300000,
                method: 'GET',
                headers: {},
                contentType: '',
                callback: null,
                url: '',
                data: '',
                suspend: true,
                maxRequest: -1,
                reconnect: true,
                maxStreamingLength: 10000000,
                lastIndex: 0,
                logLevel: 'info',
                requestCount: 0,
                fallbackMethod: 'GET',
                fallbackTransport: 'streaming',
                transport: 'long-polling',
                webSocketImpl: null,
                webSocketBinaryType: null,
                dispatchUrl: null,
                webSocketPathDelimiter: "@@",
                enableXDR: false,
                rewriteURL: false,
                attachHeadersAsQueryString: true,
                executeCallbackBeforeReconnect: false,
                readyState: 0,
                withCredentials: false,
                trackMessageLength: false,
                messageDelimiter: '|',
                connectTimeout: -1,
                reconnectInterval: 0,
                dropHeaders: true,
                uuid: 0,
                async: true,
                shared: false,
                readResponsesHeaders: false,
                maxReconnectOnClose: 5,
                enableProtocol: true,
                disableDisconnect: false,
                pollingInterval: 0,
                heartbeat: {
                    client: null,
                    server: null
                },
                ackInterval: 0,
                closeAsync: false,
                reconnectOnServerError: true,
                handleOnlineOffline: true,
                onError: function (response) {
                },
                onClose: function (response) {
                },
                onOpen: function (response) {
                },
                onMessage: function (response) {
                },
                onReopen: function (request, response) {
                },
                onReconnect: function (request, response) {
                },
                onMessagePublished: function (response) {
                },
                onTransportFailure: function (reason, request) {
                },
                onLocalMessage: function (request) {
                },
                onFailureToReconnect: function (request, response) {
                },
                onClientTimeout: function (request) {
                },
                onOpenAfterResume: function (request) {
                }
            };

            /**
             * {Object} Request's last response.
             *
             * @private
             */
            var _response = {
                status: 200,
                reasonPhrase: "OK",
                responseBody: '',
                messages: [],
                headers: [],
                state: "messageReceived",
                transport: "polling",
                error: null,
                request: null,
                partialMessage: "",
                errorHandled: false,
                closedByClientTimeout: false,
                ffTryingReconnect: false
            };

            /**
             * {websocket} Opened web socket.
             *
             * @private
             */
            var _websocket = null;

            /**
             * {SSE} Opened SSE.
             *
             * @private
             */
            var _sse = null;

            /**
             * {XMLHttpRequest, ActiveXObject} Opened ajax request (in case of http-streaming or long-polling)
             *
             * @private
             */
            var _activeRequest = null;

            /**
             * {Object} Object use for streaming with IE.
             *
             * @private
             */
            var _ieStream = null;

            /**
             * {Object} Object use for jsonp transport.
             *
             * @private
             */
            var _jqxhr = null;

            /**
             * {boolean} If request has been subscribed or not.
             *
             * @private
             */
            var _subscribed = true;

            /**
             * {number} Number of test reconnection.
             *
             * @private
             */
            var _requestCount = 0;

            /**
             * The Heartbeat interval send by the server.
             * @type {int}
             * @private
             */
            var _heartbeatInterval = 0;

            /**
             * The Heartbeat bytes send by the server.
             * @type {string}
             * @private
             */
            var _heartbeatPadding = 'X';

            /**
             * {boolean} If request is currently aborted.
             *
             * @private
             */
            var _abortingConnection = false;

            /**
             * A local "channel' of communication.
             *
             * @private
             */
            var _localSocketF = null;

            /**
             * The storage used.
             *
             * @private
             */
            var _storageService;

            /**
             * Local communication
             *
             * @private
             */
            var _localStorageService = null;

            /**
             * A Unique ID
             *
             * @private
             */
            var guid = atmosphere.util.now();

            /** Trace time */
            var _traceTimer;

            /** Key for connection sharing */
            var _sharingKey;

            /**
             * {boolean} If window beforeUnload event has been called.
             * Flag will be reset after 5000 ms
             *
             * @private
             */
            var _beforeUnloadState = false;

            // Automatic call to subscribe
            _subscribe(options);

            /**
             * Initialize atmosphere request object.
             *
             * @private
             */
            function _init() {
                _subscribed = true;
                _abortingConnection = false;
                _requestCount = 0;

                _websocket = null;
                _sse = null;
                _activeRequest = null;
                _ieStream = null;
            }

            /**
             * Re-initialize atmosphere object.
             *
             * @private
             */
            function _reinit() {
                _clearState();
                _init();
            }

            /**
             * Returns true if the given level is equal or above the configured log level.
             *
             * @private
             */
            function _canLog(level) {
                if (level == 'debug') {
                    return _request.logLevel === 'debug';
                } else if (level == 'info') {
                    return _request.logLevel === 'info' || _request.logLevel === 'debug';
                } else if (level == 'warn') {
                    return _request.logLevel === 'warn' || _request.logLevel === 'info' || _request.logLevel === 'debug';
                } else if (level == 'error') {
                    return _request.logLevel === 'error' || _request.logLevel === 'warn' || _request.logLevel === 'info' || _request.logLevel === 'debug';
                } else {
                    return false;
                }
            }

            function _debug(msg) {
                if (_canLog('debug')) {
                    atmosphere.util.debug(new Date() + " Atmosphere: " + msg);
                }
            }

            /**
             *
             * @private
             */
            function _verifyStreamingLength(ajaxRequest, rq) {
                // Wait to be sure we have the full message before closing.
                if (_response.partialMessage === "" && (rq.transport === 'streaming') && (ajaxRequest.responseText.length > rq.maxStreamingLength)) {
                    return true;
                }
                return false;
            }

            /**
             * Disconnect
             *
             * @private
             */
            function _disconnect() {
                if (_request.enableProtocol && !_request.disableDisconnect && !_request.firstMessage) {
                    var query = "X-Atmosphere-Transport=close&X-Atmosphere-tracking-id=" + _request.uuid;

                    atmosphere.util.each(_request.headers, function (name, value) {
                        var h = atmosphere.util.isFunction(value) ? value.call(this, _request, _request, _response) : value;
                        if (h != null) {
                            query += "&" + encodeURIComponent(name) + "=" + encodeURIComponent(h);
                        }
                    });

                    var url = _request.url.replace(/([?&])_=[^&]*/, query);
                    url = url + (url === _request.url ? (/\?/.test(_request.url) ? "&" : "?") + query : "");

                    var rq = {
                        connected: false
                    };
                    var closeR = new atmosphere.AtmosphereRequest(rq);
                    closeR.connectTimeout = _request.connectTimeout;
                    closeR.attachHeadersAsQueryString = false;
                    closeR.dropHeaders = true;
                    closeR.url = url;
                    closeR.contentType = "text/plain";
                    closeR.transport = 'polling';
                    closeR.method = 'GET';
                    closeR.data = '';
                    closeR.heartbeat = null;
                    if (_request.enableXDR) {
                        closeR.enableXDR = _request.enableXDR
                    }
                    closeR.async = _request.closeAsync;
                    _pushOnClose("", closeR);
                }
            }

            /**
             * Close request.
             *
             * @private
             */
            function _close() {
                _debug("Closing (AtmosphereRequest._close() called)");

                _abortingConnection = true;
                if (_request.reconnectId) {
                    clearTimeout(_request.reconnectId);
                    delete _request.reconnectId;
                }

                if (_request.heartbeatTimer) {
                    clearTimeout(_request.heartbeatTimer);
                }

                _request.reconnect = false;
                _response.request = _request;
                _response.state = 'unsubscribe';
                _response.responseBody = "";
                _response.status = 408;
                _response.partialMessage = "";
                _invokeCallback();
                _disconnect();
                _clearState();
            }

            function _clearState() {
                _response.partialMessage = "";
                if (_request.id) {
                    clearTimeout(_request.id);
                }

                if (_request.heartbeatTimer) {
                    clearTimeout(_request.heartbeatTimer);
                }

                // https://github.com/Atmosphere/atmosphere/issues/1860#issuecomment-74707226
                if(_request.reconnectId) {
                    clearTimeout(_request.reconnectId);
                    delete _request.reconnectId;
                }

                if (_ieStream != null) {
                    _ieStream.close();
                    _ieStream = null;
                }
                if (_jqxhr != null) {
                    _jqxhr.abort();
                    _jqxhr = null;
                }
                if (_activeRequest != null) {
                    _activeRequest.abort();
                    _activeRequest = null;
                }
                if (_websocket != null) {
                    if (_websocket.canSendMessage) {
                        _debug("invoking .close() on WebSocket object");
                        _websocket.close();
                    }
                    _websocket = null;
                }
                if (_sse != null) {
                    _sse.close();
                    _sse = null;
                }
                _clearStorage();
            }

            function _clearStorage() {
                // Stop sharing a connection
                if (_storageService != null) {
                    // Clears trace timer
                    clearInterval(_traceTimer);
                    // Removes the trace
                    document.cookie = _sharingKey + "=; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/";
                    // The heir is the parent unless unloading
                    _storageService.signal("close", {
                        reason: "",
                        heir: !_abortingConnection ? guid : (_storageService.get("children") || [])[0]
                    });
                    _storageService.close();
                }
                if (_localStorageService != null) {
                    _localStorageService.close();
                }
            }

            /**
             * Subscribe request using request transport. <br>
             * If request is currently opened, this one will be closed.
             *
             * @param {Object} Request parameters.
             * @private
             */
            function _subscribe(options) {
                _reinit();

                _request = atmosphere.util.extend(_request, options);
                // Allow at least 1 request
                _request.mrequest = _request.reconnect;
                if (!_request.reconnect) {
                    _request.reconnect = true;
                }
            }

            /**
             * Check if web socket is supported (check for custom implementation provided by request object or browser implementation).
             *
             * @returns {boolean} True if web socket is supported, false otherwise.
             * @private
             */
            function _supportWebsocket() {
                return _request.webSocketImpl != null || window.WebSocket || window.MozWebSocket;
            }

            /**
             * Check if server side events (SSE) is supported (check for custom implementation provided by request object or browser implementation).
             *
             * @returns {boolean} True if web socket is supported, false otherwise.
             * @private
             */
            function _supportSSE() {
                // Origin parts
                var url = atmosphere.util.getAbsoluteURL(_request.url.toLowerCase());
                var parts = /^([\w\+\.\-]+:)(?:\/\/([^\/?#:]*)(?::(\d+))?)?/.exec(url);
                var crossOrigin = !!(parts && (
                    // protocol
                parts[1] != window.location.protocol ||
                    // hostname
                parts[2] != window.location.hostname ||
                    // port
                (parts[3] || (parts[1] === "http:" ? 80 : 443)) != (window.location.port || (window.location.protocol === "http:" ? 80 : 443))
                ));
                return window.EventSource && (!crossOrigin || !atmosphere.util.browser.safari || atmosphere.util.browser.vmajor >= 7);
            }

            /**
             * Open request using request transport. <br>
             * If request transport is 'websocket' but websocket can't be opened, request will automatically reconnect using fallback transport.
             *
             * @private
             */
            function _execute() {
                // Shared across multiple tabs/windows.
                if (_request.shared) {
                    _localStorageService = _local(_request);
                    if (_localStorageService != null) {
                        if (_canLog('debug')) {
                            atmosphere.util.debug("Storage service available. All communication will be local");
                        }

                        if (_localStorageService.open(_request)) {
                            // Local connection.
                            return;
                        }
                    }

                    if (_canLog('debug')) {
                        atmosphere.util.debug("No Storage service available.");
                    }
                    // Wasn't local or an error occurred
                    _localStorageService = null;
                }

                // Protocol
                _request.firstMessage = uuid == 0 ? true : false;
                _request.isOpen = false;
                _request.ctime = atmosphere.util.now();

                // We carry any UUID set by the user or from a previous connection.
                if (_request.uuid === 0) {
                    _request.uuid = uuid;
                }
                _response.closedByClientTimeout = false;

                if (_request.transport !== 'websocket' && _request.transport !== 'sse') {
                    _executeRequest(_request);

                } else if (_request.transport === 'websocket') {
                    if (!_supportWebsocket()) {
                        _reconnectWithFallbackTransport("Websocket is not supported, using request.fallbackTransport (" + _request.fallbackTransport
                        + ")");
                    } else {
                        _executeWebSocket(false);
                    }
                } else if (_request.transport === 'sse') {
                    if (!_supportSSE()) {
                        _reconnectWithFallbackTransport("Server Side Events(SSE) is not supported, using request.fallbackTransport ("
                        + _request.fallbackTransport + ")");
                    } else {
                        _executeSSE(false);
                    }
                }
            }

            function _local(request) {
                var trace, connector, orphan, name = "atmosphere-" + request.url, connectors = {
                    storage: function () {
                        function onstorage(event) {
                            if (event.key === name && event.newValue) {
                                listener(event.newValue);
                            }
                        }

                        if (!atmosphere.util.storage) {
                            return;
                        }

                        var storage = window.localStorage,
                            get = function (key) {
                                return atmosphere.util.parseJSON(storage.getItem(name + "-" + key));
                            },
                            set = function (key, value) {
                                storage.setItem(name + "-" + key, atmosphere.util.stringifyJSON(value));
                            };

                        return {
                            init: function () {
                                set("children", get("children").concat([guid]));
                                atmosphere.util.on(window, "storage", onstorage);
                                return get("opened");
                            },
                            signal: function (type, data) {
                                storage.setItem(name, atmosphere.util.stringifyJSON({
                                    target: "p",
                                    type: type,
                                    data: data
                                }));
                            },
                            close: function () {
                                var children = get("children");

                                atmosphere.util.off(window, "storage", onstorage);
                                if (children) {
                                    if (removeFromArray(children, request.id)) {
                                        set("children", children);
                                    }
                                }
                            }
                        };
                    },
                    windowref: function () {
                        var win = window.open("", name.replace(/\W/g, ""));

                        if (!win || win.closed || !win.callbacks) {
                            return;
                        }

                        return {
                            init: function () {
                                win.callbacks.push(listener);
                                win.children.push(guid);
                                return win.opened;
                            },
                            signal: function (type, data) {
                                if (!win.closed && win.fire) {
                                    win.fire(atmosphere.util.stringifyJSON({
                                        target: "p",
                                        type: type,
                                        data: data
                                    }));
                                }
                            },
                            close: function () {
                                // Removes traces only if the parent is alive
                                if (!orphan) {
                                    removeFromArray(win.callbacks, listener);
                                    removeFromArray(win.children, guid);
                                }
                            }

                        };
                    }
                };

                function removeFromArray(array, val) {
                    var i, length = array.length;

                    for (i = 0; i < length; i++) {
                        if (array[i] === val) {
                            array.splice(i, 1);
                        }
                    }

                    return length !== array.length;
                }

                // Receives open, close and message command from the parent
                function listener(string) {
                    var command = atmosphere.util.parseJSON(string), data = command.data;

                    if (command.target === "c") {
                        switch (command.type) {
                            case "open":
                                _open("opening", 'local', _request);
                                break;
                            case "close":
                                if (!orphan) {
                                    orphan = true;
                                    if (data.reason === "aborted") {
                                        _close();
                                    } else {
                                        // Gives the heir some time to reconnect
                                        if (data.heir === guid) {
                                            _execute();
                                        } else {
                                            setTimeout(function () {
                                                _execute();
                                            }, 100);
                                        }
                                    }
                                }
                                break;
                            case "message":
                                _prepareCallback(data, "messageReceived", 200, request.transport);
                                break;
                            case "localMessage":
                                _localMessage(data);
                                break;
                        }
                    }
                }

                function findTrace() {
                    var matcher = new RegExp("(?:^|; )(" + encodeURIComponent(name) + ")=([^;]*)").exec(document.cookie);
                    if (matcher) {
                        return atmosphere.util.parseJSON(decodeURIComponent(matcher[2]));
                    }
                }

                // Finds and validates the parent socket's trace from the cookie
                trace = findTrace();
                if (!trace || atmosphere.util.now() - trace.ts > 1000) {
                    return;
                }

                // Chooses a connector
                connector = connectors.storage() || connectors.windowref();
                if (!connector) {
                    return;
                }

                return {
                    open: function () {
                        var parentOpened;

                        // Checks the shared one is alive
                        _traceTimer = setInterval(function () {
                            var oldTrace = trace;
                            trace = findTrace();
                            if (!trace || oldTrace.ts === trace.ts) {
                                // Simulates a close signal
                                listener(atmosphere.util.stringifyJSON({
                                    target: "c",
                                    type: "close",
                                    data: {
                                        reason: "error",
                                        heir: oldTrace.heir
                                    }
                                }));
                            }
                        }, 1000);

                        parentOpened = connector.init();
                        if (parentOpened) {
                            // Firing the open event without delay robs the user of the opportunity to bind connecting event handlers
                            setTimeout(function () {
                                _open("opening", 'local', request);
                            }, 50);
                        }
                        return parentOpened;
                    },
                    send: function (event) {
                        connector.signal("send", event);
                    },
                    localSend: function (event) {
                        connector.signal("localSend", atmosphere.util.stringifyJSON({
                            id: guid,
                            event: event
                        }));
                    },
                    close: function () {
                        // Do not signal the parent if this method is executed by the unload event handler
                        if (!_abortingConnection) {
                            clearInterval(_traceTimer);
                            connector.signal("close");
                            connector.close();
                        }
                    }
                };
            }

            function share() {
                var storageService, name = "atmosphere-" + _request.url, servers = {
                    // Powered by the storage event and the localStorage
                    // http://www.w3.org/TR/webstorage/#event-storage
                    storage: function () {
                        function onstorage(event) {
                            // When a deletion, newValue initialized to null
                            if (event.key === name && event.newValue) {
                                listener(event.newValue);
                            }
                        }

                        if (!atmosphere.util.storage) {
                            return;
                        }

                        var storage = window.localStorage;

                        return {
                            init: function () {
                                // Handles the storage event
                                atmosphere.util.on(window, "storage", onstorage);
                            },
                            signal: function (type, data) {
                                storage.setItem(name, atmosphere.util.stringifyJSON({
                                    target: "c",
                                    type: type,
                                    data: data
                                }));
                            },
                            get: function (key) {
                                return atmosphere.util.parseJSON(storage.getItem(name + "-" + key));
                            },
                            set: function (key, value) {
                                storage.setItem(name + "-" + key, atmosphere.util.stringifyJSON(value));
                            },
                            close: function () {
                                atmosphere.util.off(window, "storage", onstorage);
                                storage.removeItem(name);
                                storage.removeItem(name + "-opened");
                                storage.removeItem(name + "-children");
                            }

                        };
                    },
                    // Powered by the window.open method
                    // https://developer.mozilla.org/en/DOM/window.open
                    windowref: function () {
                        // Internet Explorer raises an invalid argument error
                        // when calling the window.open method with the name containing non-word characters
                        var neim = name.replace(/\W/g, ""), container = document.getElementById(neim), win;

                        if (!container) {
                            container = document.createElement("div");
                            container.id = neim;
                            container.style.display = "none";
                            container.innerHTML = '<iframe name="' + neim + '" />';
                            document.body.appendChild(container);
                        }

                        win = container.firstChild.contentWindow;

                        return {
                            init: function () {
                                // Callbacks from different windows
                                win.callbacks = [listener];
                                // In IE 8 and less, only string argument can be safely passed to the function in other window
                                win.fire = function (string) {
                                    var i;

                                    for (i = 0; i < win.callbacks.length; i++) {
                                        win.callbacks[i](string);
                                    }
                                };
                            },
                            signal: function (type, data) {
                                if (!win.closed && win.fire) {
                                    win.fire(atmosphere.util.stringifyJSON({
                                        target: "c",
                                        type: type,
                                        data: data
                                    }));
                                }
                            },
                            get: function (key) {
                                return !win.closed ? win[key] : null;
                            },
                            set: function (key, value) {
                                if (!win.closed) {
                                    win[key] = value;
                                }
                            },
                            close: function () {
                            }
                        };
                    }
                };

                // Receives send and close command from the children
                function listener(string) {
                    var command = atmosphere.util.parseJSON(string), data = command.data;

                    if (command.target === "p") {
                        switch (command.type) {
                            case "send":
                                _push(data);
                                break;
                            case "localSend":
                                _localMessage(data);
                                break;
                            case "close":
                                _close();
                                break;
                        }
                    }
                }

                _localSocketF = function propagateMessageEvent(context) {
                    storageService.signal("message", context);
                };

                function leaveTrace() {
                    document.cookie = _sharingKey + "=" +
                        // Opera's JSON implementation ignores a number whose a last digit of 0 strangely
                        // but has no problem with a number whose a last digit of 9 + 1
                    encodeURIComponent(atmosphere.util.stringifyJSON({
                        ts: atmosphere.util.now() + 1,
                        heir: (storageService.get("children") || [])[0]
                    })) + "; path=/";
                }

                // Chooses a storageService
                storageService = servers.storage() || servers.windowref();
                storageService.init();

                if (_canLog('debug')) {
                    atmosphere.util.debug("Installed StorageService " + storageService);
                }

                // List of children sockets
                storageService.set("children", []);

                if (storageService.get("opened") != null && !storageService.get("opened")) {
                    // Flag indicating the parent socket is opened
                    storageService.set("opened", false);
                }
                // Leaves traces
                _sharingKey = encodeURIComponent(name);
                leaveTrace();
                _traceTimer = setInterval(leaveTrace, 1000);

                _storageService = storageService;
            }

            /**
             * @private
             */
            function _open(state, transport, request) {
                if (_request.shared && transport !== 'local') {
                    share();
                }

                if (_storageService != null) {
                    _storageService.set("opened", true);
                }

                request.close = function () {
                    _close();
                };

                if (_requestCount > 0 && state === 're-connecting') {
                    request.isReopen = true;
                    _tryingToReconnect(_response);
                } else if (_response.error == null) {
                    _response.request = request;
                    var prevState = _response.state;
                    _response.state = state;
                    var prevTransport = _response.transport;
                    _response.transport = transport;

                    var _body = _response.responseBody;
                    _invokeCallback();
                    _response.responseBody = _body;

                    _response.state = prevState;
                    _response.transport = prevTransport;
                }
            }

            /**
             * Execute request using jsonp transport.
             *
             * @param request {Object} request Request parameters, if undefined _request object will be used.
             * @private
             */
            function _jsonp(request) {
                // When CORS is enabled, make sure we force the proper transport.
                request.transport = "jsonp";

                var rq = _request, script;
                if ((request != null) && (typeof (request) !== 'undefined')) {
                    rq = request;
                }

                _jqxhr = {
                    open: function () {
                        var callback = "atmosphere" + (++guid);

                        function _reconnectOnFailure() {
                            rq.lastIndex = 0;

                            if (rq.openId) {
                                clearTimeout(rq.openId);
                            }

                            if (rq.heartbeatTimer) {
                                clearTimeout(rq.heartbeatTimer);
                            }

                            if (rq.reconnect && _requestCount++ < rq.maxReconnectOnClose) {
                                _open('re-connecting', rq.transport, rq);
                                _reconnect(_jqxhr, rq, request.reconnectInterval);
                                rq.openId = setTimeout(function () {
                                    _triggerOpen(rq);
                                }, rq.reconnectInterval + 1000);
                            } else {
                                _onError(0, "maxReconnectOnClose reached");
                            }
                        }

                        function poll() {
                            var url = rq.url;
                            if (rq.dispatchUrl != null) {
                                url += rq.dispatchUrl;
                            }

                            var data = rq.data;
                            if (rq.attachHeadersAsQueryString) {
                                url = _attachHeaders(rq);
                                if (data !== '') {
                                    url += "&X-Atmosphere-Post-Body=" + encodeURIComponent(data);
                                }
                                data = '';
                            }

                            var head = document.head || document.getElementsByTagName("head")[0] || document.documentElement;

                            script = document.createElement("script");
                            script.src = url + "&jsonpTransport=" + callback;
                            //script.async = rq.async;
                            script.clean = function () {
                                script.clean = script.onerror = script.onload = script.onreadystatechange = null;
                                if (script.parentNode) {
                                    script.parentNode.removeChild(script);
                                }

                                if (++request.scriptCount === 2) {
                                    request.scriptCount = 1;
                                    _reconnectOnFailure();
                                }

                            };
                            script.onload = script.onreadystatechange = function () {
                                _debug("jsonp.onload");
                                if (!script.readyState || /loaded|complete/.test(script.readyState)) {
                                    script.clean();
                                }
                            };

                            script.onerror = function () {
                                _debug("jsonp.onerror");
                                request.scriptCount = 1;
                                script.clean();
                            };

                            head.insertBefore(script, head.firstChild);
                        }

                        // Attaches callback
                        window[callback] = function (msg) {
                            _debug("jsonp.window");
                            request.scriptCount = 0;
                            if (rq.reconnect && rq.maxRequest === -1 || rq.requestCount++ < rq.maxRequest) {

                                // _readHeaders(_jqxhr, rq);
                                if (!rq.executeCallbackBeforeReconnect) {
                                    _reconnect(_jqxhr, rq, rq.pollingInterval);
                                }

                                if (msg != null && typeof msg !== 'string') {
                                    try {
                                        msg = msg.message;
                                    } catch (err) {
                                        // The message was partial
                                    }
                                }
                                var skipCallbackInvocation = _trackMessageSize(msg, rq, _response);
                                if (!skipCallbackInvocation) {
                                    _prepareCallback(_response.responseBody, "messageReceived", 200, rq.transport);
                                }

                                if (rq.executeCallbackBeforeReconnect) {
                                    _reconnect(_jqxhr, rq, rq.pollingInterval);
                                }
                                _timeout(rq);
                            } else {
                                atmosphere.util.log(_request.logLevel, ["JSONP reconnect maximum try reached " + _request.requestCount]);
                                _onError(0, "maxRequest reached");
                            }
                        };
                        setTimeout(function () {
                            poll();
                        }, 50);
                    },
                    abort: function () {
                        if (script && script.clean) {
                            script.clean();
                        }
                    }
                };
                _jqxhr.open();
            }

            /**
             * Build websocket object.
             *
             * @param location {string} Web socket url.
             * @returns {websocket} Web socket object.
             * @private
             */
            function _getWebSocket(location) {
                if (_request.webSocketImpl != null) {
                    return _request.webSocketImpl;
                } else {
                    if (window.WebSocket) {
                        return new WebSocket(location);
                    } else {
                        return new MozWebSocket(location);
                    }
                }
            }

            /**
             * Build web socket url from request url.
             *
             * @return {string} Web socket url (start with "ws" or "wss" for secure web socket).
             * @private
             */
            function _buildWebSocketUrl() {
                return _attachHeaders(_request, atmosphere.util.getAbsoluteURL(_request.webSocketUrl || _request.url)).replace(/^http/, "ws");
            }

            /**
             * Build SSE url from request url.
             *
             * @return a url with Atmosphere's headers
             * @private
             */
            function _buildSSEUrl() {
                var url = _attachHeaders(_request);
                return url;
            }

            /**
             * Open SSE. <br>
             * Automatically use fallback transport if SSE can't be opened.
             *
             * @private
             */
            function _executeSSE(sseOpened) {

                _response.transport = "sse";

                var location = _buildSSEUrl();

                if (_canLog('debug')) {
                    atmosphere.util.debug("Invoking executeSSE");
                    atmosphere.util.debug("Using URL: " + location);
                }

                if (sseOpened && !_request.reconnect) {
                    if (_sse != null) {
                        _clearState();
                    }
                    return;
                }

                try {
                    _sse = new EventSource(location, {
                        withCredentials: _request.withCredentials
                    });
                } catch (e) {
                    _onError(0, e);
                    _reconnectWithFallbackTransport("SSE failed. Downgrading to fallback transport and resending");
                    return;
                }

                if (_request.connectTimeout > 0) {
                    _request.id = setTimeout(function () {
                        if (!sseOpened) {
                            _clearState();
                        }
                    }, _request.connectTimeout);
                }

                _sse.onopen = function (event) {
                    _debug("sse.onopen");
                    _timeout(_request);
                    if (_canLog('debug')) {
                        atmosphere.util.debug("SSE successfully opened");
                    }

                    if (!_request.enableProtocol) {
                        if (!sseOpened) {
                            _open('opening', "sse", _request);
                        } else {
                            _open('re-opening', "sse", _request);
                        }
                    } else if (_request.isReopen) {
                        _request.isReopen = false;
                        _open('re-opening', _request.transport, _request);
                    }

                    sseOpened = true;

                    if (_request.method === 'POST') {
                        _response.state = "messageReceived";
                        _sse.send(_request.data);
                    }
                };

                _sse.onmessage = function (message) {
                    _debug("sse.onmessage");
                    _timeout(_request);

                    if (!_request.enableXDR && window.location.host && message.origin && message.origin !== window.location.protocol + "//" + window.location.host) {
                        atmosphere.util.log(_request.logLevel, ["Origin was not " + window.location.protocol + "//" + window.location.host]);
                        return;
                    }

                    _response.state = 'messageReceived';
                    _response.status = 200;

                    message = message.data;
                    var skipCallbackInvocation = _trackMessageSize(message, _request, _response);

                    // https://github.com/remy/polyfills/blob/master/EventSource.js
                    // Since we polling.
                    /* if (_sse.URL) {
                     _sse.interval = 100;
                     _sse.URL = _buildSSEUrl();
                     } */

                    if (!skipCallbackInvocation) {
                        _invokeCallback();
                        _response.responseBody = '';
                        _response.messages = [];
                    }
                };

                _sse.onerror = function (message) {
                    _debug("sse.onerror");
                    clearTimeout(_request.id);

                    if (_request.heartbeatTimer) {
                        clearTimeout(_request.heartbeatTimer);
                    }

                    if (_response.closedByClientTimeout) {
                        return;
                    }

                    _invokeClose(sseOpened);
                    _clearState();

                    if (_abortingConnection) {
                        atmosphere.util.log(_request.logLevel, ["SSE closed normally"]);
                    } else if (!sseOpened) {
                        _reconnectWithFallbackTransport("SSE failed. Downgrading to fallback transport and resending");
                    } else if (_request.reconnect && (_response.transport === 'sse')) {
                        if (_requestCount++ < _request.maxReconnectOnClose) {
                            _open('re-connecting', _request.transport, _request);
                            if (_request.reconnectInterval > 0) {
                                _request.reconnectId = setTimeout(function () {
                                    _executeSSE(true);
                                }, _request.reconnectInterval);
                            } else {
                                _executeSSE(true);
                            }
                            _response.responseBody = "";
                            _response.messages = [];
                        } else {
                            atmosphere.util.log(_request.logLevel, ["SSE reconnect maximum try reached " + _requestCount]);
                            _onError(0, "maxReconnectOnClose reached");
                        }
                    }
                };
            }

            /**
             * Open web socket. <br>
             * Automatically use fallback transport if web socket can't be opened.
             *
             * @private
             */
            function _executeWebSocket(webSocketOpened) {

                _response.transport = "websocket";

                var location = _buildWebSocketUrl(_request.url);
                if (_canLog('debug')) {
                    atmosphere.util.debug("Invoking executeWebSocket, using URL: " + location);
                }

                if (webSocketOpened && !_request.reconnect) {
                    if (_websocket != null) {
                        _clearState();
                    }
                    return;
                }

                _websocket = _getWebSocket(location);
                if (_request.webSocketBinaryType != null) {
                    _websocket.binaryType = _request.webSocketBinaryType;
                }

                if (_request.connectTimeout > 0) {
                    _request.id = setTimeout(function () {
                        if (!webSocketOpened) {
                            var _message = {
                                code: 1002,
                                reason: "",
                                wasClean: false
                            };
                            _websocket.onclose(_message);
                            // Close it anyway
                            try {
                                _clearState();
                            } catch (e) {
                            }
                            return;
                        }

                    }, _request.connectTimeout);
                }

                _websocket.onopen = function (message) {
                    _debug("websocket.onopen");
                    _timeout(_request);
                    offline = false;

                    if (_canLog('debug')) {
                        atmosphere.util.debug("Websocket successfully opened");
                    }

                    var reopening = webSocketOpened;

                    if (_websocket != null) {
                        _websocket.canSendMessage = true;
                    }

                    if (!_request.enableProtocol) {
                        webSocketOpened = true;
                        if (reopening) {
                            _open('re-opening', "websocket", _request);
                        } else {
                            _open('opening', "websocket", _request);
                        }
                    }

                    if (_websocket != null) {
                        if (_request.method === 'POST') {
                            _response.state = "messageReceived";
                            _websocket.send(_request.data);
                        }
                    }
                };

                _websocket.onmessage = function (message) {
                    _debug("websocket.onmessage");
                    _timeout(_request);

                    // We only consider it opened if we get the handshake data
                    // https://github.com/Atmosphere/atmosphere-javascript/issues/74
                    if (_request.enableProtocol) {
                        webSocketOpened = true;
                    }

                    _response.state = 'messageReceived';
                    _response.status = 200;

                    message = message.data;
                    var isString = typeof (message) === 'string';
                    if (isString) {
                        var skipCallbackInvocation = _trackMessageSize(message, _request, _response);
                        if (!skipCallbackInvocation) {
                            _invokeCallback();
                            _response.responseBody = '';
                            _response.messages = [];
                        }
                    } else {
                        message = _handleProtocol(_request, message);
                        if (message === "")
                            return;

                        _response.responseBody = message;
                        _invokeCallback();
                        _response.responseBody = null;
                    }
                };

                _websocket.onerror = function (message) {
                    _debug("websocket.onerror");
                    clearTimeout(_request.id);

                    if (_request.heartbeatTimer) {
                        clearTimeout(_request.heartbeatTimer);
                    }
                };

                _websocket.onclose = function (message) {
                    _debug("websocket.onclose");
                    clearTimeout(_request.id);
                    if (_response.state === 'closed')
                        return;

                    var reason = message.reason;
                    if (reason === "") {
                        switch (message.code) {
                            case 1000:
                                reason = "Normal closure; the connection successfully completed whatever purpose for which it was created.";
                                break;
                            case 1001:
                                reason = "The endpoint is going away, either because of a server failure or because the "
                                + "browser is navigating away from the page that opened the connection.";
                                break;
                            case 1002:
                                reason = "The endpoint is terminating the connection due to a protocol error.";
                                break;
                            case 1003:
                                reason = "The connection is being terminated because the endpoint received data of a type it "
                                + "cannot accept (for example, a text-only endpoint received binary data).";
                                break;
                            case 1004:
                                reason = "The endpoint is terminating the connection because a data frame was received that is too large.";
                                break;
                            case 1005:
                                reason = "Unknown: no status code was provided even though one was expected.";
                                break;
                            case 1006:
                                reason = "Connection was closed abnormally (that is, with no close frame being sent).";
                                break;
                        }
                    }

                    if (_canLog('warn')) {
                        atmosphere.util.warn("Websocket closed, reason: " + reason + ' - wasClean: ' + message.wasClean);
                    }

                    if (_response.closedByClientTimeout || (_request.handleOnlineOffline && offline)) {
                        // IFF online/offline events are handled and we happen to be offline, we stop all reconnect attempts and
                        // resume them in the "online" event (if we get here in that case, something else went wrong as the
                        // offline handler should stop any reconnect attempt).
                        //
                        // On the other hand, if we DO NOT handle online/offline events, we continue as before with reconnecting
                        // even if we are offline. Failing to do so would stop all reconnect attemps forever.
                        if (_request.reconnectId) {
                            clearTimeout(_request.reconnectId);
                            delete _request.reconnectId;
                        }
                        return;
                    }

                    _invokeClose(webSocketOpened);

                    _response.state = 'closed';

                    if (_abortingConnection) {
                        atmosphere.util.log(_request.logLevel, ["Websocket closed normally"]);
                    } else if (!webSocketOpened) {
                        _reconnectWithFallbackTransport("Websocket failed on first connection attempt. Downgrading to " + _request.fallbackTransport + " and resending");

                    } else if (_request.reconnect && _response.transport === 'websocket' ) {
                        _clearState();
                        if (_requestCount++ < _request.maxReconnectOnClose) {
                            _open('re-connecting', _request.transport, _request);
                            if (_request.reconnectInterval > 0) {
                                _request.reconnectId = setTimeout(function () {
                                    _response.responseBody = "";
                                    _response.messages = [];
                                    _executeWebSocket(true);
                                }, _request.reconnectInterval);
                            } else {
                                _response.responseBody = "";
                                _response.messages = [];
                                _executeWebSocket(true);
                            }
                        } else {
                            atmosphere.util.log(_request.logLevel, ["Websocket reconnect maximum try reached " + _requestCount]);
                            if (_canLog('warn')) {
                                atmosphere.util.warn("Websocket error, reason: " + message.reason);
                            }
                            _onError(0, "maxReconnectOnClose reached");
                        }
                    }
                };

                var ua = navigator.userAgent.toLowerCase();
                var isAndroid = ua.indexOf("android") > -1;
                if (isAndroid && _websocket.url === undefined) {
                    // Android 4.1 does not really support websockets and fails silently
                    _websocket.onclose({
                        reason: "Android 4.1 does not support websockets.",
                        wasClean: false
                    });
                }
            }

            function _handleProtocol(request, message) {

                var nMessage = message;
                if (request.transport === 'polling') return nMessage;

                if (request.enableProtocol && request.firstMessage && atmosphere.util.trim(message).length !== 0) {
                    var pos = request.trackMessageLength ? 1 : 0;
                    var messages = message.split(request.messageDelimiter);

                    if (messages.length <= pos + 1) {
                        // Something went wrong, normally with IE or when a message is written before the
                        // handshake has been received.
                        return nMessage;
                    }

                    request.firstMessage = false;
                    request.uuid = atmosphere.util.trim(messages[pos]);

                    if (messages.length <= pos + 2) {
                        atmosphere.util.log('error', ["Protocol data not sent by the server. " +
                        "If you enable protocol on client side, be sure to install JavascriptProtocol interceptor on server side." +
                        "Also note that atmosphere-runtime 2.2+ should be used."]);
                    }

                    _heartbeatInterval = parseInt(atmosphere.util.trim(messages[pos + 1]), 10);
                    _heartbeatPadding = messages[pos + 2];

                    if (request.transport !== 'long-polling') {
                        _triggerOpen(request);
                    }
                    uuid = request.uuid;
                    nMessage = "";

                    // We have trailing messages
                    pos = request.trackMessageLength ? 4 : 3;
                    if (messages.length > pos + 1) {
                        for (var i = pos; i < messages.length; i++) {
                            nMessage += messages[i];
                            if (i + 1 !== messages.length) {
                                nMessage += request.messageDelimiter;
                            }
                        }
                    }

                    if (request.ackInterval !== 0) {
                        setTimeout(function () {
                            _push("...ACK...");
                        }, request.ackInterval);
                    }
                } else if (request.enableProtocol && request.firstMessage && atmosphere.util.browser.msie && +atmosphere.util.browser.version.split(".")[0] < 10) {
                    // In case we are getting some junk from IE
                    atmosphere.util.log(_request.logLevel, ["Receiving unexpected data from IE"]);
                } else {
                    _triggerOpen(request);
                }
                return nMessage;
            }

            function _timeout(_request) {
                clearTimeout(_request.id);
                if (_request.timeout > 0 && _request.transport !== 'polling') {
                    _request.id = setTimeout(function () {
                        _onClientTimeout(_request);
                        _disconnect();
                        _clearState();
                    }, _request.timeout);
                }
            }

            function _onClientTimeout(_request) {
                _response.closedByClientTimeout = true;
                _response.state = 'closedByClient';
                _response.responseBody = "";
                _response.status = 408;
                _response.messages = [];
                _invokeCallback();
            }

            function _onError(code, reason) {
                _clearState();
                clearTimeout(_request.id);
                _response.state = 'error';
                _response.reasonPhrase = reason;
                _response.responseBody = "";
                _response.status = code;
                _response.messages = [];
                _invokeCallback();
            }

            /**
             * Track received message and make sure callbacks/functions are only invoked when the complete message has been received.
             *
             * @param message
             * @param request
             * @param response
             */
            function _trackMessageSize(message, request, response) {
                message = _handleProtocol(request, message);
                if (message.length === 0)
                    return true;

                response.responseBody = message;

                if (request.trackMessageLength) {
                    // prepend partialMessage if any
                    message = response.partialMessage + message;

                    var messages = [];
                    var messageStart = message.indexOf(request.messageDelimiter);
                    if (messageStart != -1) {
                        while (messageStart !== -1) {
                            var str = message.substring(0, messageStart);
                            var messageLength = +str;
                            if (isNaN(messageLength))
                                throw new Error('message length "' + str + '" is not a number');
                            messageStart += request.messageDelimiter.length;
                            if (messageStart + messageLength > message.length) {
                                // message not complete, so there is no trailing messageDelimiter
                                messageStart = -1;
                            } else {
                                // message complete, so add it
                                messages.push(message.substring(messageStart, messageStart + messageLength));
                                // remove consumed characters
                                message = message.substring(messageStart + messageLength, message.length);
                                messageStart = message.indexOf(request.messageDelimiter);
                            }
                        }

                        /* keep any remaining data */
                        response.partialMessage = message;

                        if (messages.length !== 0) {
                            response.responseBody = messages.join(request.messageDelimiter);
                            response.messages = messages;
                            return false;
                        } else {
                            response.responseBody = "";
                            response.messages = [];
                            return true;
                        }
                    }
                }
                response.responseBody = message;
                response.messages = [message];
                return false;
            }

            /**
             * Reconnect request with fallback transport. <br>
             * Used in case websocket can't be opened.
             *
             * @private
             */
            function _reconnectWithFallbackTransport(errorMessage) {
                atmosphere.util.log(_request.logLevel, [errorMessage]);

                if (typeof (_request.onTransportFailure) !== 'undefined') {
                    _request.onTransportFailure(errorMessage, _request);
                } else if (typeof (atmosphere.util.onTransportFailure) !== 'undefined') {
                    atmosphere.util.onTransportFailure(errorMessage, _request);
                }

                _request.transport = _request.fallbackTransport;
                var reconnectInterval = _request.connectTimeout === -1 ? 0 : _request.connectTimeout;
                if (_request.reconnect && _request.transport !== 'none' || _request.transport == null) {
                    _request.method = _request.fallbackMethod;
                    _response.transport = _request.fallbackTransport;
                    _request.fallbackTransport = 'none';
                    if (reconnectInterval > 0) {
                        _request.reconnectId = setTimeout(function () {
                            _execute();
                        }, reconnectInterval);
                    } else {
                        _execute();
                    }
                } else {
                    _onError(500, "Unable to reconnect with fallback transport");
                }
            }

            /**
             * Get url from request and attach headers to it.
             *
             * @param request {Object} request Request parameters, if undefined _request object will be used.
             *
             * @returns {Object} Request object, if undefined, _request object will be used.
             * @private
             */
            function _attachHeaders(request, url) {
                var rq = _request;
                if ((request != null) && (typeof (request) !== 'undefined')) {
                    rq = request;
                }

                if (url == null) {
                    url = rq.url;
                }

                // If not enabled
                if (!rq.attachHeadersAsQueryString)
                    return url;

                // If already added
                if (url.indexOf("X-Atmosphere-Framework") !== -1) {
                    return url;
                }

                url += (url.indexOf('?') !== -1) ? '&' : '?';
                url += "X-Atmosphere-tracking-id=" + rq.uuid;
                url += "&X-Atmosphere-Framework=" + atmosphere.version;
                url += "&X-Atmosphere-Transport=" + rq.transport;

                if (rq.trackMessageLength) {
                    url += "&X-Atmosphere-TrackMessageSize=" + "true";
                }

                if (rq.heartbeat !== null && rq.heartbeat.server !== null) {
                    url += "&X-Heartbeat-Server=" + rq.heartbeat.server;
                }

                if (rq.contentType !== '') {
                    //Eurk!
                    url += "&Content-Type=" + (rq.transport === 'websocket' ? rq.contentType : encodeURIComponent(rq.contentType));
                }

                if (rq.enableProtocol) {
                    url += "&X-atmo-protocol=true";
                }

                atmosphere.util.each(rq.headers, function (name, value) {
                    var h = atmosphere.util.isFunction(value) ? value.call(this, rq, request, _response) : value;
                    if (h != null) {
                        url += "&" + encodeURIComponent(name) + "=" + encodeURIComponent(h);
                    }
                });

                return url;
            }

            function _triggerOpen(rq) {
                if (!rq.isOpen) {
                    rq.isOpen = true;
                    _open('opening', rq.transport, rq);
                } else if (rq.isReopen) {
                    rq.isReopen = false;
                    _open('re-opening', rq.transport, rq);
                } else if (_response.state === 'messageReceived' && (rq.transport === 'jsonp' || rq.transport === 'long-polling')) {
                    _openAfterResume(_response);
                } else {
                    return;
                }

                _startHeartbeat(rq);
            }

            function _startHeartbeat(rq) {
                if (rq.heartbeatTimer != null) {
                    clearTimeout(rq.heartbeatTimer);
                }

                if (!isNaN(_heartbeatInterval) && _heartbeatInterval > 0) {
                    var _pushHeartbeat = function () {
                        if (_canLog('debug')) {
                            atmosphere.util.debug("Sending heartbeat");
                        }
                        _push(_heartbeatPadding);
                        rq.heartbeatTimer = setTimeout(_pushHeartbeat, _heartbeatInterval);
                    };
                    rq.heartbeatTimer = setTimeout(_pushHeartbeat, _heartbeatInterval);
                }
            }

            /**
             * Execute ajax request. <br>
             *
             * @param request {Object} request Request parameters, if undefined _request object will be used.
             * @private
             */
            function _executeRequest(request) {
                var rq = _request;
                if ((request != null) || (typeof (request) !== 'undefined')) {
                    rq = request;
                }

                rq.lastIndex = 0;
                rq.readyState = 0;

                // CORS fake using JSONP
                if ((rq.transport === 'jsonp') || ((rq.enableXDR) && (atmosphere.util.checkCORSSupport()))) {
                    _jsonp(rq);
                    return;
                }

                if (atmosphere.util.browser.msie && +atmosphere.util.browser.version.split(".")[0] < 10) {
                    if ((rq.transport === 'streaming')) {
                        if (rq.enableXDR && window.XDomainRequest) {
                            _ieXDR(rq);
                        } else {
                            _ieStreaming(rq);
                        }
                        return;
                    }

                    if ((rq.enableXDR) && (window.XDomainRequest)) {
                        _ieXDR(rq);
                        return;
                    }
                }

                var reconnectFExec = function (force) {
                    rq.lastIndex = 0;
                    _requestCount++; // Increase also when forcing reconnect as _open checks _requestCount
                    if (force || (rq.reconnect && _requestCount <= rq.maxReconnectOnClose)) {
                        var delay = force ? 0 : request.reconnectInterval; // Reconnect immediately if the server resumed the connection (timeout)
                        _response.ffTryingReconnect = true;
                        _open('re-connecting', request.transport, request);
                        _reconnect(ajaxRequest, rq, delay);
                    } else {
                        _onError(0, "maxReconnectOnClose reached");
                    }
                };

                var reconnectF = function (force){
                    if(atmosphere._beforeUnloadState){
                        // ATMOSPHERE-JAVASCRIPT-143: Delay reconnect to avoid reconnect attempts before an actual unload (we don't know if an unload will happen, yet)
                        atmosphere.util.debug(new Date() + " Atmosphere: reconnectF: execution delayed due to _beforeUnloadState flag");
                        setTimeout(function () {
                            reconnectFExec(force);
                        }, 5000);
                    }else {
                        reconnectFExec(force);
                    }
                };

                var disconnected = function () {
                    // Prevent onerror callback to be called
                    _response.errorHandled = true;
                    _clearState();
                    reconnectF(false);
                };

                if (rq.force || (rq.reconnect && (rq.maxRequest === -1 || rq.requestCount++ < rq.maxRequest))) {
                    rq.force = false;

                    var ajaxRequest = atmosphere.util.xhr();
                    ajaxRequest.hasData = false;

                    _doRequest(ajaxRequest, rq, true);

                    if (rq.suspend) {
                        _activeRequest = ajaxRequest;
                    }

                    if (rq.transport !== 'polling') {
                        _response.transport = rq.transport;

                        ajaxRequest.onabort = function () {
                            _debug("ajaxrequest.onabort")
                            _invokeClose(true);
                        };

                        ajaxRequest.onerror = function () {
                            _debug("ajaxrequest.onerror")
                            _response.error = true;
                            _response.ffTryingReconnect = true;
                            try {
                                _response.status = XMLHttpRequest.status;
                            } catch (e) {
                                _response.status = 500;
                            }

                            if (!_response.status) {
                                _response.status = 500;
                            }
                            if (!_response.errorHandled) {
                                _clearState();
                                reconnectF(false);
                            }
                        };
                    }

                    ajaxRequest.onreadystatechange = function () {
                        _debug("ajaxRequest.onreadystatechange, new state: " + ajaxRequest.readyState);
                        if (_abortingConnection) {
                            _debug("onreadystatechange has been ignored due to _abortingConnection flag");
                            return;
                        }

                        _response.error = null;
                        var skipCallbackInvocation = false;
                        var update = false;

                        if (rq.transport === 'streaming' && rq.readyState > 2 && ajaxRequest.readyState === 4) {
                            _clearState();
                            reconnectF(false);
                            return;
                        }

                        rq.readyState = ajaxRequest.readyState;

                        if (rq.transport === 'streaming' && ajaxRequest.readyState >= 3) {
                            update = true;
                        } else if (rq.transport === 'long-polling' && ajaxRequest.readyState === 4) {
                            update = true;
                        }
                        _timeout(_request);

                        if (rq.transport !== 'polling') {
                            // MSIE 9 and lower status can be higher than 1000, Chrome can be 0
                            var status = 200;
                            if (ajaxRequest.readyState === 4) {
                                status = ajaxRequest.status > 1000 ? 0 : ajaxRequest.status;
                            }

                            if (!rq.reconnectOnServerError && (status >= 300 && status < 600)) {
                                _onError(status, ajaxRequest.statusText);
                                return;
                            }

                            if (status >= 300 || status === 0) {
                                disconnected();
                                return;
                            }

                            // Firefox incorrectly send statechange 0->2 when a reconnect attempt fails. The above checks ensure that onopen is not called for these
                            if ((!rq.enableProtocol || !request.firstMessage) && ajaxRequest.readyState === 2) {
                                // Firefox incorrectly send statechange 0->2 when a reconnect attempt fails. The above checks ensure that onopen is not called for these
                                // In that case, ajaxRequest.onerror will be called just after onreadystatechange is called, so we delay the trigger until we are
                                // guarantee the connection is well established.
                                if (atmosphere.util.browser.mozilla && _response.ffTryingReconnect) {
                                    _response.ffTryingReconnect = false;
                                    setTimeout(function () {
                                        if (!_response.ffTryingReconnect) {
                                            _triggerOpen(rq);
                                        }
                                    }, 500);
                                } else {
                                    _triggerOpen(rq);
                                }
                            }

                        } else if (ajaxRequest.readyState === 4) {
                            update = true;
                        }

                        if (update) {
                            var responseText = ajaxRequest.responseText;
                            _response.errorHandled = false;

                            // IE behave the same way when resuming long-polling or when the server goes down.
                            if (rq.transport === 'long-polling' && atmosphere.util.trim(responseText).length === 0) {
                                // For browser that aren't support onabort
                                if (!ajaxRequest.hasData) {
                                    reconnectF(true);
                                } else {
                                    ajaxRequest.hasData = false;
                                }
                                return;
                            }
                            ajaxRequest.hasData = true;

                            _readHeaders(ajaxRequest, _request);

                            if (rq.transport === 'streaming') {
                                if (!atmosphere.util.browser.opera) {
                                    var message = responseText.substring(rq.lastIndex, responseText.length);
                                    skipCallbackInvocation = _trackMessageSize(message, rq, _response);

                                    rq.lastIndex = responseText.length;
                                    if (skipCallbackInvocation) {
                                        return;
                                    }
                                } else {
                                    atmosphere.util.iterate(function () {
                                        if (_response.status !== 500 && ajaxRequest.responseText.length > rq.lastIndex) {
                                            try {
                                                _response.status = ajaxRequest.status;
                                                _response.headers = atmosphere.util.parseHeaders(ajaxRequest.getAllResponseHeaders());

                                                _readHeaders(ajaxRequest, _request);

                                            } catch (e) {
                                                _response.status = 404;
                                            }
                                            _timeout(_request);

                                            _response.state = "messageReceived";
                                            var message = ajaxRequest.responseText.substring(rq.lastIndex);
                                            rq.lastIndex = ajaxRequest.responseText.length;

                                            skipCallbackInvocation = _trackMessageSize(message, rq, _response);
                                            if (!skipCallbackInvocation) {
                                                _invokeCallback();
                                            }

                                            if (_verifyStreamingLength(ajaxRequest, rq)) {
                                                _reconnectOnMaxStreamingLength(ajaxRequest, rq);
                                                return;
                                            }
                                        } else if (_response.status > 400) {
                                            // Prevent replaying the last message.
                                            rq.lastIndex = ajaxRequest.responseText.length;
                                            return false;
                                        }
                                    }, 0);
                                }
                            } else {
                                skipCallbackInvocation = _trackMessageSize(responseText, rq, _response);
                            }
                            var closeStream = _verifyStreamingLength(ajaxRequest, rq);

                            try {
                                _response.status = ajaxRequest.status;
                                _response.headers = atmosphere.util.parseHeaders(ajaxRequest.getAllResponseHeaders());

                                _readHeaders(ajaxRequest, rq);
                            } catch (e) {
                                _response.status = 404;
                            }

                            if (rq.suspend) {
                                _response.state = _response.status === 0 ? "closed" : "messageReceived";
                            } else {
                                _response.state = "messagePublished";
                            }

                            var isAllowedToReconnect = !closeStream && request.transport !== 'streaming' && request.transport !== 'polling';
                            if (isAllowedToReconnect && !rq.executeCallbackBeforeReconnect) {
                                _reconnect(ajaxRequest, rq, rq.pollingInterval);
                            }

                            if (_response.responseBody.length !== 0 && !skipCallbackInvocation)
                                _invokeCallback();

                            if (isAllowedToReconnect && rq.executeCallbackBeforeReconnect) {
                                _reconnect(ajaxRequest, rq, rq.pollingInterval);
                            }

                            if (closeStream) {
                                _reconnectOnMaxStreamingLength(ajaxRequest, rq);
                            }
                        }
                    };

                    try {
                        ajaxRequest.send(rq.data);
                        _subscribed = true;
                    } catch (e) {
                        atmosphere.util.log(rq.logLevel, ["Unable to connect to " + rq.url]);
                        _onError(0, e);
                    }

                } else {
                    if (rq.logLevel === 'debug') {
                        atmosphere.util.log(rq.logLevel, ["Max re-connection reached."]);
                    }
                    _onError(0, "maxRequest reached");
                }
            }

            function _reconnectOnMaxStreamingLength(ajaxRequest, rq) {
                _response.messages = [];
                rq.isReopen = true;
                _close();
                _abortingConnection = false;
                _reconnect(ajaxRequest, rq, 500);
            }

            /**
             * Do ajax request.
             *
             * @param ajaxRequest Ajax request.
             * @param request Request parameters.
             * @param create If ajax request has to be open.
             */
            function _doRequest(ajaxRequest, request, create) {
                // Prevent Android to cache request
                var url = request.url;
                if (request.dispatchUrl != null && request.method === 'POST') {
                    url += request.dispatchUrl;
                }
                url = _attachHeaders(request, url);
                url = atmosphere.util.prepareURL(url);

                if (create) {
                    ajaxRequest.open(request.method, url, request.async);
                    if (request.connectTimeout > 0) {
                        request.id = setTimeout(function () {
                            if (request.requestCount === 0) {
                                _clearState();
                                _prepareCallback("Connect timeout", "closed", 200, request.transport);
                            }
                        }, request.connectTimeout);
                    }
                }

                if (_request.withCredentials && _request.transport !== 'websocket') {
                    if ("withCredentials" in ajaxRequest) {
                        ajaxRequest.withCredentials = true;
                    }
                }

                if (!_request.dropHeaders) {
                    ajaxRequest.setRequestHeader("X-Atmosphere-Framework", atmosphere.version);
                    ajaxRequest.setRequestHeader("X-Atmosphere-Transport", request.transport);

                    if (request.heartbeat !== null && request.heartbeat.server !== null) {
                        ajaxRequest.setRequestHeader("X-Heartbeat-Server", ajaxRequest.heartbeat.server);
                    }

                    if (request.trackMessageLength) {
                        ajaxRequest.setRequestHeader("X-Atmosphere-TrackMessageSize", "true");
                    }
                    ajaxRequest.setRequestHeader("X-Atmosphere-tracking-id", request.uuid);

                    atmosphere.util.each(request.headers, function (name, value) {
                        var h = atmosphere.util.isFunction(value) ? value.call(this, ajaxRequest, request, create, _response) : value;
                        if (h != null) {
                            ajaxRequest.setRequestHeader(name, h);
                        }
                    });
                }

                if (request.contentType !== '') {
                    ajaxRequest.setRequestHeader("Content-Type", request.contentType);
                }
            }

            function _reconnect(ajaxRequest, request, delay) {

                if (_response.closedByClientTimeout) {
                    return;
                }

                if (request.reconnect || (request.suspend && _subscribed)) {
                    var status = 0;
                    if (ajaxRequest && ajaxRequest.readyState > 1) {
                        status = ajaxRequest.status > 1000 ? 0 : ajaxRequest.status;
                    }
                    _response.status = status === 0 ? 204 : status;
                    _response.reason = status === 0 ? "Server resumed the connection or down." : "OK";

                    clearTimeout(request.id);
                    if (request.reconnectId) {
                        clearTimeout(request.reconnectId);
                        delete request.reconnectId;
                    }

                    if (delay > 0) {
                        // For whatever reason, never cancel a reconnect timeout as it is mandatory to reconnect.
                        _request.reconnectId = setTimeout(function () {
                            _executeRequest(request);
                        }, delay);
                    } else {
                        _executeRequest(request);
                    }
                }
            }

            function _tryingToReconnect(response) {
                response.state = 're-connecting';
                _invokeFunction(response);
            }

            function _openAfterResume(response) {
                response.state = 'openAfterResume';
                _invokeFunction(response);
                response.state = 'messageReceived';
            }

            function _ieXDR(request) {
                if (request.transport !== "polling") {
                    _ieStream = _configureXDR(request);
                    _ieStream.open();
                } else {
                    _configureXDR(request).open();
                }
            }

            function _configureXDR(request) {
                var rq = _request;
                if ((request != null) && (typeof (request) !== 'undefined')) {
                    rq = request;
                }

                var transport = rq.transport;
                var lastIndex = 0;
                var xdr = new window.XDomainRequest();
                var reconnect = function () {
                    if (rq.transport === "long-polling" && (rq.reconnect && (rq.maxRequest === -1 || rq.requestCount++ < rq.maxRequest))) {
                        xdr.status = 200;
                        _ieXDR(rq);
                    }
                };

                var rewriteURL = rq.rewriteURL || function (url) {
                        // Maintaining session by rewriting URL
                        // http://stackoverflow.com/questions/6453779/maintaining-session-by-rewriting-url
                        var match = /(?:^|;\s*)(JSESSIONID|PHPSESSID)=([^;]*)/.exec(document.cookie);

                        switch (match && match[1]) {
                            case "JSESSIONID":
                                return url.replace(/;jsessionid=[^\?]*|(\?)|$/, ";jsessionid=" + match[2] + "$1");
                            case "PHPSESSID":
                                return url.replace(/\?PHPSESSID=[^&]*&?|\?|$/, "?PHPSESSID=" + match[2] + "&").replace(/&$/, "");
                        }
                        return url;
                    };

                // Handles open and message event
                xdr.onprogress = function () {
                    handle(xdr);
                };
                // Handles error event
                xdr.onerror = function () {
                    // If the server doesn't send anything back to XDR will fail with polling
                    if (rq.transport !== 'polling') {
                        _clearState();
                        if (_requestCount++ < rq.maxReconnectOnClose) {
                            if (rq.reconnectInterval > 0) {
                                rq.reconnectId = setTimeout(function () {
                                    _open('re-connecting', request.transport, request);
                                    _ieXDR(rq);
                                }, rq.reconnectInterval);
                            } else {
                                _open('re-connecting', request.transport, request);
                                _ieXDR(rq);
                            }
                        } else {
                            _onError(0, "maxReconnectOnClose reached");
                        }
                    }
                };

                // Handles close event
                xdr.onload = function () {
                };

                var handle = function (xdr) {
                    clearTimeout(rq.id);
                    var message = xdr.responseText;

                    message = message.substring(lastIndex);
                    lastIndex += message.length;

                    if (transport !== 'polling') {
                        _timeout(rq);

                        var skipCallbackInvocation = _trackMessageSize(message, rq, _response);

                        if (transport === 'long-polling' && atmosphere.util.trim(message).length === 0)
                            return;

                        if (rq.executeCallbackBeforeReconnect) {
                            reconnect();
                        }

                        if (!skipCallbackInvocation) {
                            _prepareCallback(_response.responseBody, "messageReceived", 200, transport);
                        }

                        if (!rq.executeCallbackBeforeReconnect) {
                            reconnect();
                        }
                    }
                };

                return {
                    open: function () {
                        var url = rq.url;
                        if (rq.dispatchUrl != null) {
                            url += rq.dispatchUrl;
                        }
                        url = _attachHeaders(rq, url);
                        xdr.open(rq.method, rewriteURL(url));
                        if (rq.method === 'GET') {
                            xdr.send();
                        } else {
                            xdr.send(rq.data);
                        }

                        if (rq.connectTimeout > 0) {
                            rq.id = setTimeout(function () {
                                if (rq.requestCount === 0) {
                                    _clearState();
                                    _prepareCallback("Connect timeout", "closed", 200, rq.transport);
                                }
                            }, rq.connectTimeout);
                        }
                    },
                    close: function () {
                        xdr.abort();
                    }
                };
            }

            function _ieStreaming(request) {
                _ieStream = _configureIE(request);
                _ieStream.open();
            }

            function _configureIE(request) {
                var rq = _request;
                if ((request != null) && (typeof (request) !== 'undefined')) {
                    rq = request;
                }

                var stop;
                var doc = new window.ActiveXObject("htmlfile");

                doc.open();
                doc.close();

                var url = rq.url;
                if (rq.dispatchUrl != null) {
                    url += rq.dispatchUrl;
                }

                if (rq.transport !== 'polling') {
                    _response.transport = rq.transport;
                }

                return {
                    open: function () {
                        var iframe = doc.createElement("iframe");

                        url = _attachHeaders(rq);
                        if (rq.data !== '') {
                            url += "&X-Atmosphere-Post-Body=" + encodeURIComponent(rq.data);
                        }

                        // Finally attach a timestamp to prevent Android and IE caching.
                        url = atmosphere.util.prepareURL(url);

                        iframe.src = url;
                        doc.body.appendChild(iframe);

                        // For the server to respond in a consistent format regardless of user agent, we polls response text
                        var cdoc = iframe.contentDocument || iframe.contentWindow.document;

                        stop = atmosphere.util.iterate(function () {
                            try {
                                if (!cdoc.firstChild) {
                                    return;
                                }

                                var res = cdoc.body ? cdoc.body.lastChild : cdoc;
                                if (res.omgThisIsBroken) {
                                    // Cause an exception when res is null, to trigger a reconnect...
                                }
                                var readResponse = function () {
                                    // Clones the element not to disturb the original one
                                    var clone = res.cloneNode(true);

                                    // If the last character is a carriage return or a line feed, IE ignores it in the innerText property
                                    // therefore, we add another non-newline character to preserve it
                                    clone.appendChild(cdoc.createTextNode("."));

                                    var text = clone.innerText;

                                    text = text.substring(0, text.length - 1);
                                    return text;

                                };

                                // To support text/html content type
                                if (!cdoc.body || !cdoc.body.firstChild || cdoc.body.firstChild.nodeName.toLowerCase() !== "pre") {
                                    // Injects a plaintext element which renders text without interpreting the HTML and cannot be stopped
                                    // it is deprecated in HTML5, but still works
                                    var head = cdoc.head || cdoc.getElementsByTagName("head")[0] || cdoc.documentElement || cdoc;
                                    var script = cdoc.createElement("script");

                                    script.text = "document.write('<plaintext>')";

                                    head.insertBefore(script, head.firstChild);
                                    head.removeChild(script);

                                    // The plaintext element will be the response container
                                    res = cdoc.body.lastChild;
                                }

                                if (rq.closed) {
                                    rq.isReopen = true;
                                }

                                // Handles message and close event
                                stop = atmosphere.util.iterate(function () {
                                    var text = readResponse();
                                    if (text.length > rq.lastIndex) {
                                        _timeout(_request);

                                        _response.status = 200;
                                        _response.error = null;

                                        // Empties response every time that it is handled
                                        res.innerText = "";
                                        var skipCallbackInvocation = _trackMessageSize(text, rq, _response);
                                        if (skipCallbackInvocation) {
                                            return "";
                                        }

                                        _prepareCallback(_response.responseBody, "messageReceived", 200, rq.transport);
                                    }

                                    rq.lastIndex = 0;

                                    if (cdoc.readyState === "complete") {
                                        _invokeClose(true);
                                        _open('re-connecting', rq.transport, rq);
                                        if (rq.reconnectInterval > 0) {
                                            rq.reconnectId = setTimeout(function () {
                                                _ieStreaming(rq);
                                            }, rq.reconnectInterval);
                                        } else {
                                            _ieStreaming(rq);
                                        }
                                        return false;
                                    }
                                }, null);

                                return false;
                            } catch (err) {
                                _response.error = true;
                                _open('re-connecting', rq.transport, rq);
                                if (_requestCount++ < rq.maxReconnectOnClose) {
                                    if (rq.reconnectInterval > 0) {
                                        rq.reconnectId = setTimeout(function () {
                                            _ieStreaming(rq);
                                        }, rq.reconnectInterval);
                                    } else {
                                        _ieStreaming(rq);
                                    }
                                } else {
                                    _onError(0, "maxReconnectOnClose reached");
                                }
                                doc.execCommand("Stop");
                                doc.close();
                                return false;
                            }
                        });
                    },

                    close: function () {
                        if (stop) {
                            stop();
                        }

                        doc.execCommand("Stop");
                        _invokeClose(true);
                    }
                };
            }

            /**
             * Send message. <br>
             * Will be automatically dispatch to other connected.
             *
             * @param {Object, string} Message to send.
             * @private
             */
            function _push(message) {

                if (_localStorageService != null) {
                    _pushLocal(message);
                } else if (_activeRequest != null || _sse != null) {
                    _pushAjaxMessage(message);
                } else if (_ieStream != null) {
                    _pushIE(message);
                } else if (_jqxhr != null) {
                    _pushJsonp(message);
                } else if (_websocket != null) {
                    _pushWebSocket(message);
                } else {
                    _onError(0, "No suspended connection available");
                    atmosphere.util.error("No suspended connection available. Make sure atmosphere.subscribe has been called and request.onOpen invoked before trying to push data");
                }
            }

            function _pushOnClose(message, rq) {
                if (!rq) {
                    rq = _getPushRequest(message);
                }
                rq.transport = "polling";
                rq.method = "GET";
                rq.withCredentials = false;
                rq.reconnect = false;
                rq.force = true;
                rq.suspend = false;
                rq.timeout = 1000;
                _executeRequest(rq);
            }

            function _pushLocal(message) {
                _localStorageService.send(message);
            }

            function _intraPush(message) {
                // IE 9 will crash if not.
                if (message.length === 0)
                    return;

                try {
                    if (_localStorageService) {
                        _localStorageService.localSend(message);
                    } else if (_storageService) {
                        _storageService.signal("localMessage", atmosphere.util.stringifyJSON({
                            id: guid,
                            event: message
                        }));
                    }
                } catch (err) {
                    atmosphere.util.error(err);
                }
            }

            /**
             * Send a message using currently opened ajax request (using http-streaming or long-polling). <br>
             *
             * @param {string, Object} Message to send. This is an object, string message is saved in data member.
             * @private
             */
            function _pushAjaxMessage(message) {
                var rq = _getPushRequest(message);
                _executeRequest(rq);
            }

            /**
             * Send a message using currently opened ie streaming (using http-streaming or long-polling). <br>
             *
             * @param {string, Object} Message to send. This is an object, string message is saved in data member.
             * @private
             */
            function _pushIE(message) {
                if (_request.enableXDR && atmosphere.util.checkCORSSupport()) {
                    var rq = _getPushRequest(message);
                    // Do not reconnect since we are pushing.
                    rq.reconnect = false;
                    _jsonp(rq);
                } else {
                    _pushAjaxMessage(message);
                }
            }

            /**
             * Send a message using jsonp transport. <br>
             *
             * @param {string, Object} Message to send. This is an object, string message is saved in data member.
             * @private
             */
            function _pushJsonp(message) {
                _pushAjaxMessage(message);
            }

            function _getStringMessage(message) {
                var msg = message;
                if (typeof (msg) === 'object') {
                    msg = message.data;
                }
                return msg;
            }

            /**
             * Build request use to push message using method 'POST' <br>. Transport is defined as 'polling' and 'suspend' is set to false.
             *
             * @return {Object} Request object use to push message.
             * @private
             */
            function _getPushRequest(message) {
                var msg = _getStringMessage(message);

                var rq = {
                    connected: false,
                    timeout: 60000,
                    method: 'POST',
                    url: _request.url,
                    contentType: _request.contentType,
                    headers: _request.headers,
                    reconnect: true,
                    callback: null,
                    data: msg,
                    suspend: false,
                    maxRequest: -1,
                    logLevel: 'info',
                    requestCount: 0,
                    withCredentials: _request.withCredentials,
                    async: _request.async,
                    transport: 'polling',
                    isOpen: true,
                    attachHeadersAsQueryString: true,
                    enableXDR: _request.enableXDR,
                    uuid: _request.uuid,
                    dispatchUrl: _request.dispatchUrl,
                    enableProtocol: false,
                    messageDelimiter: '|',
                    trackMessageLength: _request.trackMessageLength,
                    maxReconnectOnClose: _request.maxReconnectOnClose,
                    heartbeatTimer: _request.heartbeatTimer,
                    heartbeat: _request.heartbeat
                };

                if (typeof (message) === 'object') {
                    rq = atmosphere.util.extend(rq, message);
                }

                return rq;
            }

            /**
             * Send a message using currently opened websocket. <br>
             *
             */
            function _pushWebSocket(message) {
                var msg = atmosphere.util.isBinary(message) ? message : _getStringMessage(message);
                var data;
                try {
                    if (_request.dispatchUrl != null) {
                        data = _request.webSocketPathDelimiter + _request.dispatchUrl + _request.webSocketPathDelimiter + msg;
                    } else {
                        data = msg;
                    }

                    if (!_websocket.canSendMessage) {
                        atmosphere.util.error("WebSocket not connected.");
                        return;
                    }

                    _websocket.send(data);

                } catch (e) {
                    _websocket.onclose = function (message) {
                    };
                    _clearState();

                    _reconnectWithFallbackTransport("Websocket failed. Downgrading to " + _request.fallbackTransport + " and resending " + message);
                    _pushAjaxMessage(message);
                }
            }

            function _localMessage(message) {
                var m = atmosphere.util.parseJSON(message);
                if (m.id !== guid) {
                    if (typeof (_request.onLocalMessage) !== 'undefined') {
                        _request.onLocalMessage(m.event);
                    } else if (typeof (atmosphere.util.onLocalMessage) !== 'undefined') {
                        atmosphere.util.onLocalMessage(m.event);
                    }
                }
            }

            function _prepareCallback(messageBody, state, errorCode, transport) {

                _response.responseBody = messageBody;
                _response.transport = transport;
                _response.status = errorCode;
                _response.state = state;

                _invokeCallback();
            }

            function _readHeaders(xdr, request) {
                if (!request.readResponsesHeaders) {
                    if (!request.enableProtocol) {
                        request.uuid = guid;
                    }
                }
                else {
                    try {

                        var tempUUID = xdr.getResponseHeader('X-Atmosphere-tracking-id');
                        if (tempUUID && tempUUID != null) {
                            request.uuid = tempUUID.split(" ").pop();
                        }
                    } catch (e) {
                    }
                }
            }

            function _invokeFunction(response) {
                _f(response, _request);
                // Global
                _f(response, atmosphere.util);
            }

            function _f(response, f) {
                switch (response.state) {
                    case "messageReceived":
                        _debug("Firing onMessage");
                        _requestCount = 0;
                        if (typeof (f.onMessage) !== 'undefined')
                            f.onMessage(response);

                        if (typeof (f.onmessage) !== 'undefined')
                            f.onmessage(response);
                        break;
                    case "error":
                        var dbgReasonPhrase = (typeof(response.reasonPhrase) != 'undefined') ? response.reasonPhrase : 'n/a';
                        _debug("Firing onError, reasonPhrase: " + dbgReasonPhrase);
                        if (typeof (f.onError) !== 'undefined')
                            f.onError(response);

                        if (typeof (f.onerror) !== 'undefined')
                            f.onerror(response);
                        break;
                    case "opening":
                        delete _request.closed;
                        _debug("Firing onOpen");
                        if (typeof (f.onOpen) !== 'undefined')
                            f.onOpen(response);

                        if (typeof (f.onopen) !== 'undefined')
                            f.onopen(response);
                        break;
                    case "messagePublished":
                        _debug("Firing messagePublished");
                        if (typeof (f.onMessagePublished) !== 'undefined')
                            f.onMessagePublished(response);
                        break;
                    case "re-connecting":
                        _debug("Firing onReconnect");
                        if (typeof (f.onReconnect) !== 'undefined')
                            f.onReconnect(_request, response);
                        break;
                    case "closedByClient":
                        _debug("Firing closedByClient");
                        if (typeof (f.onClientTimeout) !== 'undefined')
                            f.onClientTimeout(_request);
                        break;
                    case "re-opening":
                        delete _request.closed;
                        _debug("Firing onReopen");
                        if (typeof (f.onReopen) !== 'undefined')
                            f.onReopen(_request, response);
                        break;
                    case "fail-to-reconnect":
                        _debug("Firing onFailureToReconnect");
                        if (typeof (f.onFailureToReconnect) !== 'undefined')
                            f.onFailureToReconnect(_request, response);
                        break;
                    case "unsubscribe":
                    case "closed":
                        var closed = typeof (_request.closed) !== 'undefined' ? _request.closed : false;

                        if (!closed) {
                            _debug("Firing onClose (" + response.state + " case)");
                            if (typeof (f.onClose) !== 'undefined') {
                                f.onClose(response);
                            }

                            if (typeof (f.onclose) !== 'undefined') {
                                f.onclose(response);
                            }
                        } else {
                            _debug("Request already closed, not firing onClose (" + response.state + " case)");
                        }
                        _request.closed = true;
                        break;
                    case "openAfterResume":
                        if (typeof (f.onOpenAfterResume) !== 'undefined')
                            f.onOpenAfterResume(_request);
                        break;
                }
            }

            function _invokeClose(wasOpen) {
                if (_response.state !== 'closed') {
                    _response.state = 'closed';
                    _response.responseBody = "";
                    _response.messages = [];
                    _response.status = !wasOpen ? 501 : 200;
                    _invokeCallback();
                }
            }

            /**
             * Invoke request callbacks.
             *
             * @private
             */
            function _invokeCallback() {
                var call = function (index, func) {
                    func(_response);
                };

                if (_localStorageService == null && _localSocketF != null) {
                    _localSocketF(_response.responseBody);
                }

                _request.reconnect = _request.mrequest;

                var isString = typeof (_response.responseBody) === 'string';
                var messages = (isString && _request.trackMessageLength) ? (_response.messages.length > 0 ? _response.messages : ['']) : new Array(
                    _response.responseBody);
                for (var i = 0; i < messages.length; i++) {

                    if (messages.length > 1 && messages[i].length === 0) {
                        continue;
                    }
                    _response.responseBody = (isString) ? atmosphere.util.trim(messages[i]) : messages[i];

                    if (_localStorageService == null && _localSocketF != null) {
                        _localSocketF(_response.responseBody);
                    }

                    if ((_response.responseBody.length === 0 ||
                        (isString && _heartbeatPadding === _response.responseBody)) && _response.state === "messageReceived") {
                        continue;
                    }

                    _invokeFunction(_response);

                    // Invoke global callbacks
                    if (callbacks.length > 0) {
                        if (_canLog('debug')) {
                            atmosphere.util.debug("Invoking " + callbacks.length + " global callbacks: " + _response.state);
                        }
                        try {
                            atmosphere.util.each(callbacks, call);
                        } catch (e) {
                            atmosphere.util.log(_request.logLevel, ["Callback exception" + e]);
                        }
                    }

                    // Invoke request callback
                    if (typeof (_request.callback) === 'function') {
                        if (_canLog('debug')) {
                            atmosphere.util.debug("Invoking request callbacks");
                        }
                        try {
                            _request.callback(_response);
                        } catch (e) {
                            atmosphere.util.log(_request.logLevel, ["Callback exception" + e]);
                        }
                    }
                }
            }

            this.subscribe = function (options) {
                _subscribe(options);
                _execute();
            };

            this.execute = function () {
                _execute();
            };

            this.close = function () {
                _close();
            };

            this.disconnect = function () {
                _disconnect();
            };

            this.getUrl = function () {
                return _request.url;
            };

            this.push = function (message, dispatchUrl) {
                if (dispatchUrl != null) {
                    var originalDispatchUrl = _request.dispatchUrl;
                    _request.dispatchUrl = dispatchUrl;
                    _push(message);
                    _request.dispatchUrl = originalDispatchUrl;
                } else {
                    _push(message);
                }
            };

            this.getUUID = function () {
                return _request.uuid;
            };

            this.pushLocal = function (message) {
                _intraPush(message);
            };

            this.enableProtocol = function (message) {
                return _request.enableProtocol;
            };

            this.init = function () {
                _init();
            };

            this.request = _request;
            this.response = _response;
        }
    };

    atmosphere.subscribe = function (url, callback, request) {
        if (typeof (callback) === 'function') {
            atmosphere.addCallback(callback);
        }

        if (typeof (url) !== "string") {
            request = url;
        } else {
            request.url = url;
        }

        // https://github.com/Atmosphere/atmosphere-javascript/issues/58
        uuid = ((typeof (request) !== 'undefined') && typeof (request.uuid) !== 'undefined') ? request.uuid : 0;

        var rq = new atmosphere.AtmosphereRequest(request);
        rq.execute();

        requests[requests.length] = rq;
        return rq;
    };

    atmosphere.unsubscribe = function () {
        if (requests.length > 0) {
            var requestsClone = [].concat(requests);
            for (var i = 0; i < requestsClone.length; i++) {
                var rq = requestsClone[i];
                rq.close();
                clearTimeout(rq.response.request.id);

                if (rq.heartbeatTimer) {
                    clearTimeout(rq.heartbeatTimer);
                }
            }
        }
        requests = [];
        callbacks = [];
    };

    atmosphere.unsubscribeUrl = function (url) {
        var idx = -1;
        if (requests.length > 0) {
            for (var i = 0; i < requests.length; i++) {
                var rq = requests[i];

                // Suppose you can subscribe once to an url
                if (rq.getUrl() === url) {
                    rq.close();
                    clearTimeout(rq.response.request.id);

                    if (rq.heartbeatTimer) {
                        clearTimeout(rq.heartbeatTimer);
                    }

                    idx = i;
                    break;
                }
            }
        }
        if (idx >= 0) {
            requests.splice(idx, 1);
        }
    };

    atmosphere.addCallback = function (func) {
        if (atmosphere.util.inArray(func, callbacks) === -1) {
            callbacks.push(func);
        }
    };

    atmosphere.removeCallback = function (func) {
        var index = atmosphere.util.inArray(func, callbacks);
        if (index !== -1) {
            callbacks.splice(index, 1);
        }
    };

    atmosphere.util = {
        browser: {},

        parseHeaders: function (headerString) {
            var match, rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg, headers = {};
            while (match = rheaders.exec(headerString)) {
                headers[match[1]] = match[2];
            }
            return headers;
        },

        now: function () {
            return new Date().getTime();
        },

        isArray: function (array) {
            return Object.prototype.toString.call(array) === "[object Array]";
        },

        inArray: function (elem, array) {
            if (!Array.prototype.indexOf) {
                var len = array.length;
                for (var i = 0; i < len; ++i) {
                    if (array[i] === elem) {
                        return i;
                    }
                }
                return -1;
            }
            return array.indexOf(elem);
        },

        isBinary: function (data) {
            // True if data is an instance of Blob, ArrayBuffer or ArrayBufferView
            return /^\[object\s(?:Blob|ArrayBuffer|.+Array)\]$/.test(Object.prototype.toString.call(data));
        },

        isFunction: function (fn) {
            return Object.prototype.toString.call(fn) === "[object Function]";
        },

        getAbsoluteURL: function (url) {
            if (typeof (document.createElement) === 'undefined') {
                // assuming the url to be already absolute when DOM is not supported
                return url;
            }
            var div = document.createElement("div");

            // Uses an innerHTML property to obtain an absolute URL
            div.innerHTML = '<a href="' + url + '"/>';

            // encodeURI and decodeURI are needed to normalize URL between IE and non-IE,
            // since IE doesn't encode the href property value and return it - http://jsfiddle.net/Yq9M8/1/
            return encodeURI(decodeURI(div.firstChild.href));
        },

        prepareURL: function (url) {
            // Attaches a time stamp to prevent caching
            var ts = atmosphere.util.now();
            var ret = url.replace(/([?&])_=[^&]*/, "$1_=" + ts);

            return ret + (ret === url ? (/\?/.test(url) ? "&" : "?") + "_=" + ts : "");
        },

        trim: function (str) {
            if (!String.prototype.trim) {
                return str.toString().replace(/(?:(?:^|\n)\s+|\s+(?:$|\n))/g, "").replace(/\s+/g, " ");
            } else {
                return str.toString().trim();
            }
        },

        param: function (params) {
            var prefix, s = [];

            function add(key, value) {
                value = atmosphere.util.isFunction(value) ? value() : (value == null ? "" : value);
                s.push(encodeURIComponent(key) + "=" + encodeURIComponent(value));
            }

            function buildParams(prefix, obj) {
                var name;

                if (atmosphere.util.isArray(obj)) {
                    atmosphere.util.each(obj, function (i, v) {
                        if (/\[\]$/.test(prefix)) {
                            add(prefix, v);
                        } else {
                            buildParams(prefix + "[" + (typeof v === "object" ? i : "") + "]", v);
                        }
                    });
                } else if (Object.prototype.toString.call(obj) === "[object Object]") {
                    for (name in obj) {
                        buildParams(prefix + "[" + name + "]", obj[name]);
                    }
                } else {
                    add(prefix, obj);
                }
            }

            for (prefix in params) {
                buildParams(prefix, params[prefix]);
            }

            return s.join("&").replace(/%20/g, "+");
        },

        storage: function () {
            try {
                return !!(window.localStorage && window.StorageEvent);
            } catch (e) {
                //Firefox throws an exception here, see
                //https://bugzilla.mozilla.org/show_bug.cgi?id=748620
                return false;
            }
        },

        iterate: function (fn, interval) {
            var timeoutId;

            // Though the interval is 0 for real-time application, there is a delay between setTimeout calls
            // For detail, see https://developer.mozilla.org/en/window.setTimeout#Minimum_delay_and_timeout_nesting
            interval = interval || 0;

            (function loop() {
                timeoutId = setTimeout(function () {
                    if (fn() === false) {
                        return;
                    }

                    loop();
                }, interval);
            })();

            return function () {
                clearTimeout(timeoutId);
            };
        },

        each: function (obj, callback, args) {
            if (!obj) return;
            var value, i = 0, length = obj.length, isArray = atmosphere.util.isArray(obj);

            if (args) {
                if (isArray) {
                    for (; i < length; i++) {
                        value = callback.apply(obj[i], args);

                        if (value === false) {
                            break;
                        }
                    }
                } else {
                    for (i in obj) {
                        value = callback.apply(obj[i], args);

                        if (value === false) {
                            break;
                        }
                    }
                }

                // A special, fast, case for the most common use of each
            } else {
                if (isArray) {
                    for (; i < length; i++) {
                        value = callback.call(obj[i], i, obj[i]);

                        if (value === false) {
                            break;
                        }
                    }
                } else {
                    for (i in obj) {
                        value = callback.call(obj[i], i, obj[i]);

                        if (value === false) {
                            break;
                        }
                    }
                }
            }

            return obj;
        },

        extend: function (target) {
            var i, options, name;

            for (i = 1; i < arguments.length; i++) {
                if ((options = arguments[i]) != null) {
                    for (name in options) {
                        target[name] = options[name];
                    }
                }
            }

            return target;
        },
        on: function (elem, type, fn) {
            if (elem.addEventListener) {
                elem.addEventListener(type, fn, false);
            } else if (elem.attachEvent) {
                elem.attachEvent("on" + type, fn);
            }
        },
        off: function (elem, type, fn) {
            if (elem.removeEventListener) {
                elem.removeEventListener(type, fn, false);
            } else if (elem.detachEvent) {
                elem.detachEvent("on" + type, fn);
            }
        },

        log: function (level, args) {
            if (window.console) {
                var logger = window.console[level];
                if (typeof logger === 'function') {
                    logger.apply(window.console, args);
                }
            }
        },

        warn: function () {
            atmosphere.util.log('warn', arguments);
        },

        info: function () {
            atmosphere.util.log('info', arguments);
        },

        debug: function () {
            atmosphere.util.log('debug', arguments);
        },

        error: function () {
            atmosphere.util.log('error', arguments);
        },
        xhr: function () {
            try {
                return new window.XMLHttpRequest();
            } catch (e1) {
                try {
                    return new window.ActiveXObject("Microsoft.XMLHTTP");
                } catch (e2) {
                }
            }
        },
        parseJSON: function (data) {
            return !data ? null : window.JSON && window.JSON.parse ? window.JSON.parse(data) : new Function("return " + data)();
        },
        // http://github.com/flowersinthesand/stringifyJSON
        stringifyJSON: function (value) {
            var escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, meta = {
                '\b': '\\b',
                '\t': '\\t',
                '\n': '\\n',
                '\f': '\\f',
                '\r': '\\r',
                '"': '\\"',
                '\\': '\\\\'
            };

            function quote(string) {
                return '"' + string.replace(escapable, function (a) {
                        var c = meta[a];
                        return typeof c === "string" ? c : "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4);
                    }) + '"';
            }

            function f(n) {
                return n < 10 ? "0" + n : n;
            }

            return window.JSON && window.JSON.stringify ? window.JSON.stringify(value) : (function str(key, holder) {
                var i, v, len, partial, value = holder[key], type = typeof value;

                if (value && typeof value === "object" && typeof value.toJSON === "function") {
                    value = value.toJSON(key);
                    type = typeof value;
                }

                switch (type) {
                    case "string":
                        return quote(value);
                    case "number":
                        return isFinite(value) ? String(value) : "null";
                    case "boolean":
                        return String(value);
                    case "object":
                        if (!value) {
                            return "null";
                        }

                        switch (Object.prototype.toString.call(value)) {
                            case "[object Date]":
                                return isFinite(value.valueOf()) ? '"' + value.getUTCFullYear() + "-" + f(value.getUTCMonth() + 1) + "-"
                                + f(value.getUTCDate()) + "T" + f(value.getUTCHours()) + ":" + f(value.getUTCMinutes()) + ":" + f(value.getUTCSeconds())
                                + "Z" + '"' : "null";
                            case "[object Array]":
                                len = value.length;
                                partial = [];
                                for (i = 0; i < len; i++) {
                                    partial.push(str(i, value) || "null");
                                }

                                return "[" + partial.join(",") + "]";
                            default:
                                partial = [];
                                for (i in value) {
                                    if (hasOwn.call(value, i)) {
                                        v = str(i, value);
                                        if (v) {
                                            partial.push(quote(i) + ":" + v);
                                        }
                                    }
                                }

                                return "{" + partial.join(",") + "}";
                        }
                }
            })("", {
                "": value
            });
        },

        checkCORSSupport: function () {
            if (atmosphere.util.browser.msie && !window.XDomainRequest && +atmosphere.util.browser.version.split(".")[0] < 11) {
                return true;
            } else if (atmosphere.util.browser.opera && +atmosphere.util.browser.version.split(".") < 12.0) {
                return true;
            }

            // KreaTV 4.1 -> 4.4
            else if (atmosphere.util.trim(navigator.userAgent).slice(0, 16) === "KreaTVWebKit/531") {
                return true;
            }
            // KreaTV 3.8
            else if (atmosphere.util.trim(navigator.userAgent).slice(-7).toLowerCase() === "kreatel") {
                return true;
            }

            // Force older Android versions to use CORS as some version like 2.2.3 fail otherwise
            var ua = navigator.userAgent.toLowerCase();
            var androidVersionMatches = ua.match(/.+android ([0-9]{1,2})/i),
                majorVersion = parseInt((androidVersionMatches && androidVersionMatches[0]) || -1, 10);
            if (!isNaN(majorVersion) && majorVersion > -1 && majorVersion < 3) {
                return true;
            }
            return false;
        }
    };

    guid = atmosphere.util.now();

    // Browser sniffing
    (function () {
        var ua = navigator.userAgent.toLowerCase(),
            match = /(chrome)[ \/]([\w.]+)/.exec(ua) ||
                /(opera)(?:.*version|)[ \/]([\w.]+)/.exec(ua) ||
                /(msie) ([\w.]+)/.exec(ua) ||
                /(trident)(?:.*? rv:([\w.]+)|)/.exec(ua) ||
                ua.indexOf("android") < 0 && /version\/(.+) (safari)/.exec(ua) ||
                ua.indexOf("compatible") < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(ua) ||
                [];

        // Swaps variables
        if (match[2] === "safari") {
            match[2] = match[1];
            match[1] = "safari";
        }
        atmosphere.util.browser[match[1] || ""] = true;
        atmosphere.util.browser.version = match[2] || "0";
        atmosphere.util.browser.vmajor = atmosphere.util.browser.version.split(".")[0];

        // Trident is the layout engine of the Internet Explorer
        // IE 11 has no "MSIE: 11.0" token
        if (atmosphere.util.browser.trident) {
            atmosphere.util.browser.msie = true;
        }

        // The storage event of Internet Explorer and Firefox 3 works strangely
        if (atmosphere.util.browser.msie || (atmosphere.util.browser.mozilla && +atmosphere.util.browser.version.split(".")[0] === 1)) {
            atmosphere.util.storage = false;
        }
    })();

    atmosphere.util.on(window, "unload", function (event) {
        atmosphere.util.debug(new Date() + " Atmosphere: " + "unload event");
        atmosphere.unsubscribe();
    });

    atmosphere.util.on(window, "beforeunload", function (event) {
        atmosphere.util.debug(new Date() + " Atmosphere: " + "beforeunload event");

        // ATMOSPHERE-JAVASCRIPT-143: Delay reconnect to avoid reconnect attempts before an actual unload (we don't know if an unload will happen, yet)
        atmosphere._beforeUnloadState = true;
        setTimeout(function () {
            atmosphere.util.debug(new Date() + " Atmosphere: " + "beforeunload event timeout reached. Reset _beforeUnloadState flag");
            atmosphere._beforeUnloadState = false;
        }, 5000);
    });

    // Pressing ESC key in Firefox kills the connection
    // for your information, this is fixed in Firefox 20
    // https://bugzilla.mozilla.org/show_bug.cgi?id=614304
    atmosphere.util.on(window, "keypress", function (event) {
        if (event.charCode === 27 || event.keyCode === 27) {
            if (event.preventDefault) {
                event.preventDefault();
            }
        }
    });

    atmosphere.util.on(window, "offline", function () {
        atmosphere.util.debug(new Date() + " Atmosphere: offline event");
        offline = true;
        if (requests.length > 0) {
            var requestsClone = [].concat(requests);
            for (var i = 0; i < requestsClone.length; i++) {
                var rq = requestsClone[i];
                if(rq.request.handleOnlineOffline) {
                    rq.close();
                    clearTimeout(rq.response.request.id);

                    if (rq.heartbeatTimer) {
                        clearTimeout(rq.heartbeatTimer);
                    }
                }
            }
        }
    });

    atmosphere.util.on(window, "online", function () {
        atmosphere.util.debug(new Date() + " Atmosphere: online event");
        if (requests.length > 0) {
            for (var i = 0; i < requests.length; i++) {
                if(requests[i].request.handleOnlineOffline) {
                    requests[i].init();
                    requests[i].execute();
                }
            }
        }
        offline = false;
    });

    return atmosphere;
}));
/* jshint eqnull:true, noarg:true, noempty:true, eqeqeq:true, evil:true, laxbreak:true, undef:true, browser:true, indent:false, maxerr:50 */
/** krpano-content/krpano-wrapper-style/js/live/live.js **/
'use strict';
var Live = function(krpanoEmbeded, krpano, api, detectedEvent, plugin, comunication, interactions, producer) {
    this.krpanoEmbeded = krpanoEmbeded;
    this.krpano = krpano;
    this.api = api;
    this.detectedEvent = detectedEvent;
    this.comunication = comunication;
    this.interactions = interactions;
    this.producer = producer;

    if (jsonData.playerMode == 'LIVE_MASTER') {
        var instance = this;
        var  that = this;
        setTimeout(function () {
            that.toggleUserControlPanel();
            instance.inviteUser();
            instance.getTours(0);
        }, 0);
    }
    this.showInfoPoint();
    this.setEventListeners();

    CommonPlayer.call(this, krpanoEmbeded);
    jsonData.participants = {};
};

Live.prototype = Object.create(CommonPlayer.prototype);
Live.prototype.constructor = Live;

Live.prototype.setEventListeners = function() {
    var instance = this;
    this.krpanoEmbeded.on('touchend, click', '#welcome-window input[name="legal-agreement"]', function(){
        if ($(this).is(':checked')) {
            $(this).closest('#welcome-window').find('.start').removeAttr('disabled');
        } else {
            $(this).closest('#welcome-window').find('.start').attr('disabled', true);
        }
    });

    this.krpanoEmbeded.on('touchend, click', '#welcome-window .start', function(){
        instance.api.acceptPrivacyPolicy(jsonData.email);
    });

    this.krpanoEmbeded.on(this.detectedEvent, '#logout', function(){
        var hidden = !(Object.keys(jsonData.participants).length > 0 && jsonData.userRoles && jsonData.userRoles.indexOf('DOCUSKETCH') === -1);
        instance.krpanoEmbeded.find('#logout-modal .additional-info, #logout-modal .send-allow-visit-tour').toggleClass('hidden', hidden);
        instance.krpanoEmbeded.find('#logout-modal').modal('show');

    });
    this.krpanoEmbeded.on(this.detectedEvent, '#logout-modal .send-allow-visit-tour', function(){
        if (jsonData.playerMode === 'LIVE_MASTER') {
            Object.keys(jsonData.participants).forEach(function(email) {
                if (jsonData.participants[email].participantType === "LIVE_SLAVE"){
                    instance.sendVisitEmail(jsonData.participants[email]);
                }
            });
        }
        instance.producer.exitAndSendExit('/portal/');
    });
    this.krpanoEmbeded.on(this.detectedEvent, '#logout-modal .yes', function(){
        var exitUrl = jsonData.urls.backendUrls.exitUrl;
        if (jsonData.playerMode === 'LIVE_MASTER') {
            exitUrl = '/portal/';
        }
        instance.producer.exitAndSendExit(exitUrl);
    });


    if (jsonData.playerMode === 'LIVE_MASTER') {
        this.krpanoEmbeded.on(this.detectedEvent, '.infpoint-popup .fullscreen-wrapper', function() {
            var uniqueName = $(this).closest('.infpoint-popup').attr('data-unique-name');
            var show = $(this).hasClass('active');
            instance.comunication.sendInfoPointFullScreen(uniqueName, show);
        });


        this.krpanoEmbeded.on(this.detectedEvent, '.live-follow-guest-header', function (event) {
            $(this).parent('.live-follow-guest-interaction').toggleClass('active');
        });

        this.krpanoEmbeded.on(this.detectedEvent, '#open-invitation-modal', function() {
            $('#invitation-modal').modal('show');
            $('#invitation-modal').find('.btn-register').addClass('disabled');
        });
    }
};

Live.prototype.toggleUserControlPanel = function () {
    var instance = this;
    $('.live-user-list-container, #invite-participants-page-mobile').on(this.detectedEvent, '.live-user-wrapper', function() {
        if (!$(this).hasClass('active')) {
            instance.handleChangeActive($(this), true);
        }
    });
    $('.live-user-list-page, #invite-participants-page-mobile').on(this.detectedEvent, '.live-info-btn', function (e) {
        console.log(123);
        var email   = $(this).attr("data-email");
        var contact = jsonData.participants[email].contact;

        $('.live-user-information').find('.username').text(instance.comunication.getContactName(contact));
        $('.live-user-information').find('.email').text(email);
        $('.live-user-information').find('.telf').text(contact.contactPhone);
        $('.live-user-information').modal('show');

        e.preventDefault();
        e.stopPropagation();
    });
    $('.live-user-list-page, #invite-participants-page-mobile').on(this.detectedEvent, '.live-sign-out-btn', function (e) {
        var destination = $(this).attr('data-email');
        $('#live-remove-participant').attr("destination", destination).modal('show');

        e.preventDefault();
        e.stopPropagation();
    });
    this.krpanoEmbeded.on(this.detectedEvent, '.switch-role', function() {
        email = Object.keys(jsonData.participants).filter(function (email) {
            return jsonData.participants[email] && jsonData.participants[email].backMonitorActive
        })[0];
        instance.comunication.switchRoles(email);
    });

    this.krpanoEmbeded.on('mouseenter', '.plans__content .floorplan', function() {
        instance.comunication.sendMapExpand(true);
    });
    this.krpanoEmbeded.on('mouseleave', '.plans__content .floorplan', function() {
        instance.comunication.sendMapExpand(false);
    });
};

Live.prototype.initCountryPlugin = function () {
    $("#new-user-country").intlTelInput({
        initialCountry: !Cookies.get('activeFlag') ? window.jsonData.lang.toLowerCase().substr(3) : Cookies.get('activeFlag').substr(3),
        utilsScript: window.baseUrl + '/krpano-common/js/utils.js' // just for formatting/placeholders etc
    });
};

Live.prototype.init = function(){
    this.krpanoEmbeded.find("#session_number").text(window.jsonData.live.code);
    this.krpanoEmbeded.find(".invitation_link").html(window.location.origin + '/portal/guest');
}


Live.prototype.removeParticipant = function (participant) {
    var cleanName = this.cleanString(participant.contact.contactEMail);

    this.krpanoEmbeded.find('.live-chat-wrapper .tab-pane#user-' + cleanName).remove();
    this.krpanoEmbeded.find('.live-user-wrapper#' + cleanName).remove();

    this.toggleParticipantsList(participant);
    this.handleChangeActive($('.live-user-wrapper:visible'), false);
}

/*
userType - can be equal to 0 || 1; 0 - author(ME) messages styles, 1 - guest messages styles
userName - if userType === 0 then by default userName === 'me';
           if userType === 1 then userName === userName;
messageText - message content
*/
Live.prototype.messageTemplate = function(userType, userName, messageHour, messageMinutes, messageText, fileMessagePart) {
    userName  = !userType ? 'me' : userName;
    return '<div class="live-chat-message-wrapper user-' + userType + '">' +
        '<div class="live-chat-message-container"> ' +
        '<div class="user-name-wrapper">' +
        '<i class="fa fa-user"></i>' +
        '<div class="name">' + userName + ':' + '</div> ' +
        '<span class="timestamp">' + messageHour + ':' + messageMinutes + '</span> ' +
        '</div> ' +
        '<div class="message' + (fileMessagePart ? ' file-message' : '') + '">' + messageText + '</div> ' +
        fileMessagePart +
        '</div>' +
        '</div>';
}

Live.prototype.toggleUnreadMessageBadge = function(buttonId) {
    $(buttonId + ' .message-badge').removeClass('hidden');
    $(buttonId).on(this.detectedEvent, function (e) {
        $(buttonId + ' .message-badge').addClass('hidden');
    })
};

// $this - indicator that indicate in what chat element have happened interaction;
Live.prototype.selfChat = function($this, messageText, file, filePath) {
    var instance        = this;
    var destinations    = [];
    var destinationElem = '';
    var messageTime     = new Date();
    var messageMinutes  = messageTime.getMinutes() < 10 ? '0' + messageTime.getMinutes() : messageTime.getMinutes();
    var messageHour     = messageTime.getHours();
    var fileMessagePart = '';
    var name            = 'You';

    if (!this.krpanoEmbeded.find('#send-to-all').is(":checked")) {
        destinations[0] = $this.closest(".tab-pane").prop("id").replace("user-", "");
        destinationElem = '#user-' + destinations[0];
    } else {
        destinations = Object.keys(jsonData.participants).filter(function (email) {
            return jsonData.participants[email] && jsonData.participants[email].participantType !== "LIVE_MASTER" && 
            jsonData.participants[email].participantType !== "LIVE_BACKMONITOR";
        }).map(function (email) { return instance.cleanString(email); });
    }


    if (file) {
        $this.parent().find('input[type="file"]').val('');
        messageText = file.name.trim();
        destinations.forEach(function (email, key) {
            instance.comunication.sendFile(messageText, filePath, email);
        });
        fileMessagePart = '<div class="file-message-label"' + this.getMainColor() + '>' + window.lang.translate("live.info.chat.tab.file.sent") + '</div>';

    } else {
        $this.parent().find('.message-field').val('');
        destinations.forEach(function (email, key) {
            instance.comunication.sendChatMessage(messageText, email);
        });
    }

    if (messageText && messageText.length > 0) {
        $(document).find('.tab-pane' + destinationElem + ' .live-chat-body .mCSB_container')
                   .append(this.messageTemplate(0, name, messageHour, messageMinutes, messageText, fileMessagePart));
    }

}
Live.prototype.receiverChat = function(data, file) {
    var destinationCleanEmail = this.cleanString(jsonData.email);
    var senderCleanEmail      = this.cleanString(data.participant.contact.contactEMail);
    var messageTime     = new Date();
    var messageMinutes  = messageTime.getMinutes() < 10 ? '0' + messageTime.getMinutes() : messageTime.getMinutes();
    var messageHour     = messageTime.getHours();
    var fileMessagePart = '';
    var destination     = '';
    var name            = this.comunication.getContactName(data.participant.contact);

    // msg sent from master to slave shown in slave window! check destination with email
    if (data.participant.participantType === 'LIVE_MASTER' && jsonData.playerMode === 'LIVE_SLAVE' && data.destination.length != 0 && destinationCleanEmail !== data.destination) {
        return;
    }
    //msg sent from slave to master shown in master view in correct destination user tab
    if (data.participant.participantType === 'LIVE_SLAVE' && jsonData.playerMode === 'LIVE_MASTER') {
        destination = '#user-' + senderCleanEmail;
    }


    if (file) {
        fileMessagePart = '<a href="' + data.url + '" download="" class="file-download-message-label">' + window.lang.translate("live.info.chat.tab.file.download") + '</a>';
    }
    if ((data.chatMessage) && data.chatMessage.length > 0) {
        $(document).find('.tab-pane' + destination + ' .live-chat-body .mCSB_container')
                   .append(this.messageTemplate(1, name, messageHour, messageMinutes, data.chatMessage, fileMessagePart));
    }
}

Live.prototype.sendChatMessage = function () {
    var instance = this;
    this.krpanoEmbeded.on(this.detectedEvent, '.live-tour-list-page.page-active .pagination li > a, #tour-list-page-mobile .pagination li > a', function(e){
        var newPageNumber = $(this).data('page-number');
        instance.getTours(newPageNumber);
        e.preventDefault();
    });

    $('.live-chat-wrapper').on(this.detectedEvent, '.send-mesaage-btn', function () {
        var messageText = $(this).parent().find('.message-field').val();
        instance.selfChat($(this), messageText);
    });

    $('.live-chat-wrapper').on('keyup', '.message-field', function (e) {
        var messageText = $(this).val();
        if (e.keyCode == 13) instance.selfChat($(this), messageText);
    });

    $('.live-chat-wrapper').on('change', 'input[type="file"]', function (e) {
        var file = e.target.files[0];
        var chat = $(this);

        if (file !== null && typeof file !== 'undefined'){
            var url  = jsonData.urls.backendUrls.uploadFileLive.replace("%7BCODE%7D", jsonData.live.code);
            var form = $(this).parents("form");
            var postData = new FormData($(form)[0]);


            $.ajax({
                url : url,
                type : 'POST',
                data : postData,
                processData: false,
                contentType: false,
                cache: false
            })
            .then(function(response) {
                instance.selfChat(chat, null, file, response);
            })
            .fail(function() {
                chat.val('');
                instance.showError(window.lang.translate("live.info.chat.tab.file.not.sent"), 4000);
            });

        }
    });
}

Live.prototype.homePageAccordionInteraction = function () {
    this.krpanoEmbeded.on(this.detectedEvent, '.live-page-header', function () {
        $(this).parents('section').toggleClass('active');
        $(this).siblings('.live-page-content').toggleClass('hidden');
    });
};

//Add participant to the menu
Live.prototype.addParticipant = function(participant) {
     var data = {
         participantType: participant.participantType,
         color: participant.color,
         device: participant.device,
         contact: participant.contact
     };
     jsonData.participants[participant.contact.contactEMail] = data;
}

Live.prototype.addParticipantInteraction = function(participant, runFirstTime) {
    this.addParticipant(participant);

    var that          = this;
    var cleanName     = this.cleanString(participant.contact.contactEMail);
    var usersListMenu = $('.live-user-list-container');
    var alreadyExists = usersListMenu.find('#' + cleanName).size() != 0;

    if (participant.participantType === 'LIVE_MASTER' && jsonData.playerMode === 'LIVE_SLAVE') {
        $('#live-no-master').modal('hide');
    }
    if (participant.participantType === 'LIVE_SLAVE' && jsonData.playerMode === 'LIVE_MASTER') {
        var modal = this.krpanoEmbeded.find('#live-allow-visit-tour-modal');
        if (modal.is(':visible') && modal.data('email') == participant.contact.contactEMail) {
            modal.modal('hide');
        }
    }

    if (!alreadyExists && participant.contact.contactEMail !== jsonData.email) {
        if (!this.krpanoEmbeded.find("#live-chat-template").length) {
            setTimeout(function () {
                that.addParticipantElement(participant);
            }, 0);
        } else {
            that.addParticipantElement(participant);
        }

    }
}


Live.prototype.toggleParticipantsList = function(participant) {
    if (participant.participantType === 'LIVE_SLAVE' && jsonData.playerMode === 'LIVE_MASTER') {
        var participantsNumber = this.getParticipantsNumber();
        this.krpanoEmbeded.find('.live-user-list-container #no-participants').toggleClass('hidden', participantsNumber > 0);
        this.krpanoEmbeded.find('#send-to-all').parent().toggleClass('hidden', !(participantsNumber > 1));
        // this.krpanoEmbeded.find('.live-user-wrapper[attr-email="ALLPARTICIPANTS"]').toggleClass('hidden', !(participantsNumber > 1));
    }
}

Live.prototype.addParticipantElement = function (participant, runFirstTime) {
    var instance = this;
    var userElement         = this.krpanoEmbeded.find("#single_user_wrapper").clone();
    var userChatElement     = this.krpanoEmbeded.find("#live-chat-template").clone();
    var userChatElementBody = userChatElement.find(".dynamically");


    if (participant.participantType === 'LIVE_SLAVE' && jsonData.playerMode === 'LIVE_MASTER') {
        var cleanEmail = this.cleanString(participant.contact.contactEMail);
        var email = participant.contact.contactEMail;
        var allowChangeScene = null, text = null;
        var name = this.comunication.getContactName(participant.contact);

        var options = {
            placement: 'bottom',
            html: true,
            viewport: {selector: '.live-user-list-wrapper', right: 0},
            content: '<ul class="addition-live-btns">' +
                        '<li class="live-info-btn" data-email="'+email+'"><i class="fa fa-info-circle"></i> <span class="info-item" lang="en_us">live.user.list.actions.participant.info</span></li>' +
                        '<li class="live-switch-role-btn hidden"><i class="fa fa-exchange"></i><span class="switch-role" lang="en_us">live.user.list.actions.participant.switch.role</span></li>' +
                        '<li class="live-sign-out-btn" data-email="'+email+'" data-id="'+cleanEmail+'"><i class="fa fa-sign-out"></i> <span class="sign-out-item" lang="en_us">live.user.list.actions.participant.logout</span></li>' +
                     '</ul>',
            container: '.live-user-list-wrapper',
            trigger: 'focus',
            template: '<div class="popover" style="right: 0" tabindex="0" role="button"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content" style="padding: 0"></div></div>'
        };

        userElement.attr("href", '#user-' + cleanEmail).addClass("live-user-wrapper").attr("attr-email", email);
        userElement.prop("id", cleanEmail);
        userElement.find(".live-user-name").text(name);
        userElement.attr("data-user-name", name);

        userElement.find(".live-pointer-btn").attr('data-id', cleanEmail);
        userElement.find(".live-pointer-btn").attr('data-email', email);
        userElement.find(".live-pointer-btn").tooltip({container: 'body'});

        userElement.insertAfter(this.krpanoEmbeded.find(".live-user-wrapper:last")).toggle("highlight");


        runFirstTime ? userChatElement.prop("id", 'user-' + cleanEmail).addClass('active') :  userChatElement.prop("id", 'user-' + cleanEmail).addClass('hidden');
        userChatElement.find(".live-page-header").text(window.lang.translate("live.info.chat.tab.title").replace("{0}", name));

        this.handleChangeActive(userElement, false);
        this.toggleParticipantsList(participant);

        this.krpanoEmbeded.find('#' + cleanEmail + ' .live-more').popover(options);
        this.krpanoEmbeded.find('#' + cleanEmail + ' .live-more').on(this.detectedEvent, function (e) {
            if (jsonData.userRoles && jsonData.userRoles.indexOf('ADMIN') != -1) { instance.krpanoEmbeded.find('.live-switch-role-btn').removeClass('hidden') }
            if (jsonData.participants[email].switchedRole) { instance.krpanoEmbeded.find('.live-switch-role-btn').addClass('active') }

            window.lang.translateSingleElement('.switch-role', Cookies.get('activeFlag') || window.jsonData.lang.toLowerCase());
            window.lang.translateSingleElement('.info-item', Cookies.get('activeFlag') || window.jsonData.lang.toLowerCase());
            window.lang.translateSingleElement('.sign-out-item', Cookies.get('activeFlag') || window.jsonData.lang.toLowerCase());
            e.stopPropagation()
        })


    } else if (participant.participantType === 'LIVE_MASTER' && jsonData.playerMode === 'LIVE_SLAVE') {
        var masterInfo = this.getCurrentMaster().contact;
        var cleanEmail = this.cleanString(masterInfo.contactEMail);
        userChatElement.prop("id", 'user-' + cleanEmail).addClass('active').removeClass('hidden');

    } else {
        return;
    }

    userChatElement.insertAfter(this.krpanoEmbeded.find(".live-chat-wrapper .tab-content .tab-pane:last")).toggle("highlight");

    //$('.live-user-wrapper#' + cleanEmail).click();
    if (participant.participantType === 'LIVE_SLAVE' && jsonData.playerMode === 'LIVE_MASTER') {
        $('.live-chat-wrapper .tab-pane').each(function (index, element) {
            if (index === 1 && !$(element).hasClass('active')) $(element).addClass('active')
        });
    }

    userChatElementBody.mCustomScrollbar({callbacks:{
        onUpdate:function(){
            userChatElementBody.mCustomScrollbar("scrollTo",'bottom');
        }
    }})

};

Live.prototype.getActiveParticipant = function() {
    var participantEmail = this.krpanoEmbeded.find('.live-user-wrapper.active').attr('attr-email');
    return jsonData.participants[participantEmail] || false;
}

Live.prototype.setParticipantAsActive = function(email) {
    this.krpanoEmbeded.find('.live-user-wrapper').removeClass('active');
    this.krpanoEmbeded.find('.live-user-wrapper[attr-email="' + email + '"]').addClass('active');
}

Live.prototype.handleChangeActive = function($this, setParticipantAsActive) {
    var numParticipants = this.getParticipantsNumber();
    var backMonitorElement = this.krpanoEmbeded.find('.live-follow-guest-interaction');

    backMonitorElement.slideUp();

    if (numParticipants == 0 || !$this) {
        return;
    }


    var oldParticipant = this.getActiveParticipant();
    if (oldParticipant) { oldParticipant.backMonitorActive = null; }

    var participantEmail = $this.attr('attr-email');
    var participant      = jsonData.participants[participantEmail];

    if (numParticipants == 1) {
        backMonitorElement.slideDown();

        participant.backMonitorActive = true;
        this.previewWindowChangeParticipant(participant);
    }

    if (setParticipantAsActive || numParticipants == 1) {
        this.setParticipantAsActive(participantEmail);
    }
}

Live.prototype.previewWindowChangeParticipant = function(participant){
    if (participant.backMonitorActive){
        if ($(document).innerWidth() > 768) {
            this.krpanoEmbeded.find('.live-follow-guest-interaction').slideDown().unbind();
            var box = $(".live-follow-guest-interaction");
                box.find("#preview-name b").text(this.comunication.getContactName(participant.contact));
                box.find("header i").removeClass("fa-desktop").addClass("fa-" + participant.device.toLowerCase());
        }
        var url = window.location.href.indexOf("?") === -1 ? window.location.href + "?playerMode=LIVE_BACKMONITOR" : "&playerMode=LIVE_BACKMONITOR";
        $("#VIRTUAL_TOUR_BACKMONITOR").attr("src", url);

        this.comunication.sendSelectBuyer(participant);
    }
}

Live.prototype.showRightMenu = function(activePageName, delay){
    this.interactions.toggleMenu(activePageName);
    if(delay && delay > 0){
       this.interactions.closeRightMenu();
    }
}

Live.prototype.getCurrentMaster = function(){
    var participants = jsonData.participants;
    var master = false;

    Object.keys(participants).forEach(function(email){
        if (participants[email].participantType === "LIVE_MASTER" || participants[email].participantType === "LIVE_BACKMONITOR"){
            master = participants[email];
        }
    });

    return master;
}

Live.prototype.inviteUser = function(){
    var instance = this;

    this.krpanoEmbeded.find("form#invite-modal button.btn-register").on(this.detectedEvent, function(e) {
        e.stopImmediatePropagation();

        var btn  = $(this);
        var form = $(this).closest("form#invite-modal");
        var modal = $(this).closest(".modal");
        var url  = jsonData.urls.backendUrls.saveContact.replace("%7BDOMAIN%7D", "IMMOVIEWER").replace("%7BCODE%7D", jsonData.live.code);
        var status;

        btn.button("loading");

        $.ajax({
            url:  url,
            type: "POST",
            data: $(form).serialize(),
        })
        .then(function() {
            form.find("input.registration-input, .select-gender").val("");

            status = "success";
        })
        .fail(function() {
            status = "error";
        })
        .always(function(textStatus) {
            btn.button("reset");
            modal.modal("hide");
            instance.showMessage(status, window.lang.translate("live.invite.user.email." + status), 4000);
        });

        return false;
    });
};

Live.prototype.toggleInviteUserBtn = function() {
    this.krpanoEmbeded.on('keyup', '#invite-email', function () {
        !$(this).val().length ? $('.btn-register').addClass('disabled') : $('.btn-register').removeClass('disabled');
    })
};

Live.prototype.showInfoPoint = function(){
    var that = this;
    $('.info-point-item').on(this.detectedEvent, function () {
        var index = +$(this).attr('data-index');
        var type  = $(this).attr('data-type');
        var name  = $(this).attr('data-name');
        var url   = $(this).attr('data-url');
        var uniqueId    = $(this).attr('data-id');
        var description = $(this).attr('data-description');
        that.comunication.sendInfoPointData(false, null, type, name, description, url, uniqueId);
    })
};


Live.prototype.showSendVisitModal = function(participant){
    var contactName = this.comunication.getContactName(participant.contact);
    
    if (jsonData.userRoles && jsonData.userRoles.indexOf('DOCUSKETCH') !== -1) {
        this.showError(contactName + window.lang.translate("live.modals.participant.invite.title"), 4000);
    } else {
        var instance = this;
        var modal    = this.krpanoEmbeded.find('#live-allow-visit-tour-modal');

        modal.modal('show').data('email', participant.contact.contactEMail);
        modal.find('.user-name').text(contactName);
        modal.find('#send-allow-visit-tour').on('click', function(e) {
            instance.sendVisitEmail(participant, modal);
        });
        modal.on('hidden.bs.modal', function() {
            modal.data('email', '');
        });
    }
}

Live.prototype.sendVisitEmail = function(participant, modal) {
    var instance = this;
    var request = $.get(jsonData.urls.backendUrls.sendVisitEmail.replace("%7BEMAIL%7D", participant.contact.contactEMail).replace("%7BCODE%7D", jsonData.live.code));
    request.success(function() {
        status = 'success';
    }).error(function() {
        status = 'error';
    }).always(function() {
        if (modal) { modal.modal('hide').data('email', ''); }
        instance.showMessage(status, window.lang.translate("live.invite.user.email." + status), 4000);
    });
}

Live.prototype.pagination = function(currentPage) {
    var paginationTemplate = '<div class="paging_simple_numbers"><ul class="pagination pagination-sm">';

    if (jsonData.editorTheme !== 'IMMOVIEWER_DEFAULT') {
        if (currentPage.pageIndex > 0) {
            paginationTemplate +=   '<li class="first"><a href="#" lang="en_us" data-page-number="0"><i class="fa fa-angle-double-left"></i>' + window.lang.translate("right.menu.pagination.first") + '</a></li>' +
                '<li class="prev"><a href="#" data-page-number="' + (currentPage.pageIndex - 1) + '">' + currentPage.pageIndex + '</a></li>';
        }
        paginationTemplate += '<li class="active"><a>' + (currentPage.pageIndex + 1) + '</a></li>';
        if (currentPage.hasNext) {
            paginationTemplate +=   '<li class="next"> <a href="#" data-page-number="' + (currentPage.pageIndex + 1) + '">' + (currentPage.pageIndex + 2) + '</a></li>' +
                '<li class="last"> <a href="#" lang="en_us" data-page-number="' + (currentPage.pageCount - 1) + '">' + window.lang.translate("right.menu.pagination.last") + '<i class="fa fa-angle-double-right"></i></a></li>';
        }
    } else {
        var themColor = '';
        if(!jsonData.visibility.defaultColor) {themColor = 'them-color'}
        paginationTemplate += '<li class="active load-more-btn"><a href="#" data-page-number="' + (currentPage.pageIndex+1) + '" class="'+themColor+'"> show more <i class="fa fa fa-angle-down"></i></a></li>';
    }
    paginationTemplate += '</ul></div>';

    this.krpanoEmbeded.find('.tour-list-pagination').empty();
    this.krpanoEmbeded.find('.tour-list-pagination').append(paginationTemplate);
}

Live.prototype.tourTemplate = function(tour) {
    var startBtnText   = window.lang.translate("right.menu.live.show.other.tours.start");
    var internalIdText = window.lang.translate("right.menu.live.show.other.tours.internalID");
    var imgSrc = (tour.panoramas.length > 0 && !jQuery.isEmptyObject(tour.panoramas[0].fileUrls) ? tour.panoramas[0].fileUrls.THUMB : "");

    var tourTemplate =
        '<div class="start-new-tour-wrapper">' +
            '<div class="col-xs-12 col-sm-5 image-side">' +
                '<img src="' + imgSrc + '" class="img-responsive" alt="">' +
            '</div>' +
            '<div class="col-xs-12 col-sm-7 description-side">' +
                '<div class="tour-description-wrapper">' +
                    '<p class="tour-name">' + tour.name + '</p>' +
                    '<p class="tour-id"> <span lang="en_us" data-translation-pattern="right.menu.live.show.other.tours.internalID">' + internalIdText + '</span> <span> ' + tour.internalID + '</span></p>' +
                '</div>' +
                '<div class="start-btn-wrapper">' +
                    '<button lang="en_us" data-translation-pattern="right.menu.live.show.other.tours.start" class="btn btn-block them-color txt-color-white pull-right start-btn"' +
                    this.getMainColor() + ' data-id="' + tour.itemID + '">' + startBtnText + '</button>' +
                '</div>' +
            '</div>' +
        '</div>';

    return tourTemplate;
}

Live.prototype.getTours = function(startPage) {
    var url      = jsonData.urls.backendUrls.getOtherTours.replace(9999, 3).replace(8888, startPage).replace("&p.order=%7BORDER%7D", "").replace("&p.sortBy=%7BSORT%7D", "").replace("%7BSCOPE%7D", "panoramas,attachments,internalID");
    var email    = jsonData.email;
    var instance = this;
    var noTours  = window.lang.translate("right.menu.live.show.other.tours.no.tours");

    if (jsonData.editorTheme !== 'IMMOVIEWER_DEFAULT') {instance.krpanoEmbeded.find('.new-tour-list > div').empty();}

    $.ajax({
        url: url,
        type: "GET",
        headers: {
            "Authorization": "Basic " + btoa(email + ":" + decodeURIComponent(jsonData.pass))
        },
    })
    .then(function(data) {
        console.log(data);
        if (data.list.length == 0) {
            jsonData.editorTheme !== 'IMMOVIEWER_DEFAULT' ? instance.krpanoEmbeded.find('section.new-tour-list > div').append('<p>' + noTours + '</p>')
                                                          : $('.load-more-btn').attr('disabled', true);
            return;
        }

        $.each(data.list, function(key, tour) {
            if (tour.id != jsonData.tour.id) {
                instance.krpanoEmbeded.find('section.new-tour-list > div').append(instance.tourTemplate(tour));
            }
        });

        instance.pagination(data);
        instance.openOtherTour();
    })
    .fail(function(e) {
        jsonData.editorTheme !== 'IMMOVIEWER_DEFAULT' ? instance.krpanoEmbeded.find('section.new-tour-list > div').append('<p>' + noTours + '</p>')
                                                      : $('.load-more-btn').attr('disabled', true);
    });

    return false;
}

Live.prototype.openOtherTour = function () {
    var instance = this;

    this.krpanoEmbeded.on('touchend, click', '.start-btn-wrapper button', function (e) {
        e.preventDefault();
        var elemID = $(this).data('id');
        var modal  = instance.krpanoEmbeded.find("#open-other-virtual-tour-modal");

        modal.modal('show');
        modal.find('#open-other-virtual-tour').on('click', function(e) {
            modal.modal('hide');

            var request = $.get( jsonData.urls.backendUrls.easyStartOnlineViewing.replace('%7BOTHERTOURID%7D', elemID)
            .replace('%7BROOMTYPE%7D', 'VIRTUAL_TOUR').replace('%7BCODE%7D', jsonData.live.code));

            request.success(function(data) {
                instance.comunication.sendChangeItem(data.url);
            }).error(function(error) {
                instance.showError(window.lang.translate("right.menu.live.show.other.tours.open.error"), 4000);
            });

            return false;
        });
    });
};

Live.prototype.getParticipantsNumber = function() {
    return Object.keys(jsonData.participants).filter(function (email) {
        return jsonData.participants[email] && jsonData.participants[email].participantType !== "LIVE_MASTER" 
            && jsonData.participants[email].participantType !== "LIVE_BACKMONITOR" 
    }).length;
}

Live.prototype.getMainColor = function() {
    return 'style="background-color: rgba(' + jsonData.styles.mainColor.r + ', ' + jsonData.styles.mainColor.g + ', ' + jsonData.styles.mainColor.b + ', 0.85);"';
}

Live.prototype.switchedRoleParticipant = function() {
    return Object.keys(jsonData.participants).filter(function (email) {
        return jsonData.participants[email] && jsonData.participants[email].switchedRole
    })[0];
}

Live.prototype.switchRoles = function(data) {
    if (jsonData.playerMode !== 'LIVE_BACKMONITOR') {
        if (jsonData.playerMode === 'LIVE_MASTER') {
            this.krpanoEmbeded.find('.live-user-wrapper .switch-role').removeClass('active');
        }

        var switched = this.switchedRoleParticipant();
        if (switched && switched !== data.origin) {
            if (this.producer.switchedRole && jsonData.email === switched) {
                // this user had switchedRole before, but agent switche role for another user
                this.producer.switchedRole = this.producer.allowChangeScene = false;
                this.showInfo(window.lang.translate("live.immoviewer.player.switch.role.slave.false"), 4000);
            } else {
                jsonData.participants[switched].switchedRole = false;
            }

            if (jsonData.playerMode === 'LIVE_MASTER') {
                this.krpanoEmbeded.find('.live-user-wrapper[attr-email="' + data.origin + '"] .switch-role').addClass('active');
            }
        }


        if (jsonData.participants[data.origin]) {
            jsonData.participants[data.origin].switchedRole = !jsonData.participants[data.origin].switchedRole;
        }

        if (jsonData.email === data.origin) {
            this.producer.switchedRole = !this.producer.switchedRole;
            this.producer.allowChangeScene = this.producer.switchedRole;

            this.showInfo(window.lang.translate("live.immoviewer.player.switch.role.slave." + this.producer.switchedRole), 4000);
            return;
        }
    }
}

/** krpano-content/krpano-wrapper-style/js/live/live_comunication_common.js **/
'use strict';
var LiveComunication = function(krpanoEmbeded, krpano) {
    this.krpanoEmbeded = krpanoEmbeded;
    this.krpano = krpano;
    this.roomType = "VIRTUAL_TOUR";
    this.subSocket;
    this.previousPositionSent;
    this.request;
    this.init();
    CommonPlayer.call(this, krpanoEmbeded);
};

//Messages are defined in RoomBaseEvent

LiveComunication.prototype = Object.create(CommonPlayer.prototype);
LiveComunication.prototype.constructor = LiveComunication;

// Send position (with scene and with width and height of the player area)
// data = extended data options
// delay = delay time in ms.
// init = boolean which defined if it is the first time or not (to send the position)
LiveComunication.prototype.sendPositionCommon = function(data, delay, init) {
    //Setting to false the default value of init
    var instance=this;
    var currentTime = new Date().getTime();

    if(!this.previousPositionSent || currentTime > this.previousPositionSent +300){
        init = (init == null || init === undefined) ? false : init;
        //Setting the default values to data
        data.type = init ? "INIT_POSITION" : "CHANGE_POS";
        var vlookat = this.krpano.get("view.vlookat");
        var hlookat = this.krpano.get("view.hlookat");
        var fov = this.krpano.get("view.fov");
        var scene = this.krpano.get("xml.scene");
        data.scene = scene;
        data.fov = fov;
        data.vlookat = vlookat;
        data.hlookat = hlookat;
        data.roomType = this.roomType;
        data.origin = jsonData.email;
        var json = atmosphere.util.stringifyJSON(data);
        instance.previousPositionSent = currentTime;
        if(this.subSocket){
            if (delay && delay > 0) {
                setTimeout(function() {instance.subSocket.push(json)}, delay);
            } else {
                instance.subSocket.push(json);
            }
            console.log("Sending "+data.type+" message to the server= " + json);
        }
    }
};

LiveComunication.prototype.sendClick = function(x, y){
    var instance = this;
    var json = atmosphere.util.stringifyJSON({
        roomType: instance.roomType,
        type: "DOUBLE_CLICK",
        doubleClickH: x,
        doubleClickV: y
    });
    console.log("Sending DOUBLE_CLICK message to the server= " + json);
    this.subSocket.push(json);
}

LiveComunication.prototype.sendSelectBuyer = function(participant) {
    var instance = this;
    var username = this.getContactName(participant.contact);
    var text     = window.lang.translate("live.master.messages.select_buyer").replace("{0}", username);

    if (this.subSocket === null || typeof this.subSocket == "undefined") {
        setTimeout(function() {instance.sendSelectBuyer(participant)}, 200);
        return;
    }

    var json = atmosphere.util.stringifyJSON({
        roomType: instance.roomType,
        type: "SELECT_BUYER",
        destination: participant.contact.contactEMail
    });
    console.log("Sending SELECT_BUYER message to the server= " + json);
    this.subSocket.push(json);
    instance.showInfo(text, 4000);
}


LiveComunication.prototype.init = function() {
    this.request = this.initCommon();
}

LiveComunication.prototype.initCommon = function() {
    console.log("URL==" + (window.jsonData.live.url + window.jsonData.live.code + "?email=" + window.jsonData.email + "&mode=" + window.jsonData.live.mode));
    var instance = this;
    var request = {
        // see https://github.com/Atmosphere/atmosphere/wiki/jQuery.atmosphere.js-atmosphere.js-API
        url: window.jsonData.live.url + "?email=" + window.jsonData.email + "&mode=" + window.jsonData.playerMode,
        contentType: "application/json",
        logLevel: 'info',
        transport: 'websocket',
        enableXDR: !instance.isOldIE(),
        trackMessageLength: true,
        reconnectInterval: 1000,
        maxReconnectOnClose: 10,
        fallbackTransport: 'long-polling'
    };

    this.websocketErrorCatching(request);

    return request;
}

LiveComunication.prototype.isOldIE = function(){
    if(navigator.appVersion.indexOf('Trident/')>-1){// Begin stupid IE crap
        var IE=navigator.appVersion;
        IE=IE.slice(IE.indexOf('Trident/')+8);
        IE=IE.slice(0,IE.indexOf(';'));
        IE=Number(IE);
        return (IE>=4&&IE<7); // IE 8 through IE 10
    }
    return false;
}

LiveComunication.prototype.websocketErrorCatching = function(request) {
    // see https://github.com/Atmosphere/atmosphere/wiki/Understanding-JavaScript-functions for the workflows/events
    var instance = this;
    request.onClose = function(response) {
        console.log("onClose");
    };

    request.onError = function(response) {
        var text=window.lang.translate("live.error.connection.onError");
        instance.showError(text);
        console.log('onError:', response);
    };

    request.onReconnect = function(request, response) {
        var text=window.lang.translate("live.error.connection.onReconnect");
        instance.showError(text);
        console.log('onReconnect:', response);
    };

    request.onReopen = function(response) {
        console.log("onReopen");
        instance.krpanoEmbeded.find("#top_feedback_error").removeClass("show")
    };

    request.onTransportFailure = function(errorMsg, response) {
        if (errorMsg && errorMsg.indexOf("Websocket is not supported") == -1) { // fallback to websocket is not an error, so don't show a message
            instance.showError("Leider konnte keine Verbindung zum Server aufgebaut werden: " + errorMsg);
        }
        console.log("onTransportFailure: " + errorMsg);
    };
}

LiveComunication.prototype.sendChatMessage = function(message, destination) {
    var instance = this;
    var json = atmosphere.util.stringifyJSON({
        roomType: instance.roomType,
        type: "CHAT_MESSAGE",
        chatMessage: message,
        destination: destination
    });

    this.subSocket.push(json);
    console.log("Sending CHAT_MESSAGE message to the server= " + json);
    return false;
}

LiveComunication.prototype.sendFile = function(fileName, filePath, destination) {
    var instance = this;
    var json = atmosphere.util.stringifyJSON({
        roomType: instance.roomType,
        type: "SEND_FILE",
        chatMessage: fileName,
        url: filePath,
        destination: destination
    });

    this.subSocket.push(json);
    console.log("Sending SEND_FILE message to the server= " + json);
    return false;
}

//Send to the websocket the method to change the item (when an agent opens another tour in current live session)
LiveComunication.prototype.sendChangeItem = function(url) {
    var json = atmosphere.util.stringifyJSON({
        roomType: "VIRTUAL_TOUR",
        type: "CHANGE_ITEM",
        url: url
    });
    this.subSocket.push(json);
    return false;
};

LiveComunication.prototype.sendInfoPointData = function(toClose, id, type, name, description, url, uniqueId) {
    var instance = this;
    var json = atmosphere.util.stringifyJSON({
        roomType: instance.roomType,
        type: "OPEN_INFOPOINT",
        infoPoint: {toClose: toClose, id: id, type: type, name: name, description: description, url: url, uniqueId: uniqueId}
    });
    this.subSocket.push(json);
    return false;
};

LiveComunication.prototype.sendInfoPointFullScreen = function(uniqueName, show) {
    var instance = this;
    var json = atmosphere.util.stringifyJSON({
        roomType: instance.roomType,
        type: "INFOPOINT_FULLSCREEN",
        visible: show ? "SHOW" : "HIDE",
        infoPoint: {uniqueName: uniqueName}
    });
    this.subSocket.push(json);
    return false;
};

LiveComunication.prototype.switchRoles = function(email) {
    var instance = this;
    var json = atmosphere.util.stringifyJSON({
        roomType: instance.roomType,
        origin: email,
        type: "SWITCH_ROLES"
    });
    this.subSocket.push(json);

    if (jsonData.participants[email]) {
        var name = (jsonData.participants[email].contact.firstName || '') + ' ' + (jsonData.participants[email].contact.lastName || '');
        var text = window.lang.translate("live.immoviewer.player.switch.role.master." + !!jsonData.participants[email].switchedRole).replace("{0}", name);
        this.showInfo(text, 4000);
    }

    return false;
}

LiveComunication.prototype.sendMapExpand = function(show) {
    var instance = this;
    var json = atmosphere.util.stringifyJSON({
        roomType: instance.roomType,
        visible: show ? "SHOW" : "HIDE",
        type: "MAP_EXPAND"
    });
    this.subSocket.push(json);
    return false;
};

LiveComunication.prototype.getContactName = function(contact) {
    var name = "";
    if (contact.firstName && contact.lastName) {
        name = contact.firstName + " " + contact.lastName;
    } else {
        name = contact.firstName || contact.lastName || "";
    }
    if (!name) {
        name = contact.contactEMail;
    }
    return name;
}
/** krpano-content/krpano-wrapper-style/js/live/live_consumer.js **/
'use strict';
var LiveConsumer = function(krpanoEmbeded, krpano, api, detectedEvent, comunication, menu, producer, infopoint, floorplan) {
   this.krpanoEmbeded = krpanoEmbeded;
   this.krpano = krpano;
   this.api = api;
   this.infopoint = infopoint;
   this.floorplan = floorplan;
   this.detectedEvent = detectedEvent;
   this.comunication = comunication;
   this.masterPresent = false;
   this.menu = menu;
   this.producer = producer;
//    this.conference = conference;
   //Interval while the session window remains open after a person joins or exit
   this.internalOnJoinOrExit = 5000;
   var instance = this;
    CommonPlayer.call(this, krpanoEmbeded);
    var setLanguageCallback = function () {
        if (window.lang.currentLang != undefined) {
            window.lang.loadPack(window.lang.currentLang, function (err) {
                if (!err) {
                    instance.init();
                } else {}
            });
        }else{
            setTimeout(setLanguageCallback,500);
        }
    };
    setTimeout(setLanguageCallback,1000);
};

LiveConsumer.prototype = Object.create(CommonPlayer.prototype);
LiveConsumer.prototype.constructor = LiveConsumer;

LiveConsumer.prototype.init = function(){
    var instance = this;
    this.comunication.request.onMessage = function(response) {
        var data;
        try {
            var message = response.responseBody;
            data = atmosphere.util.parseJSON(message);
        } catch (e) {
            console.log('This doesn\'t look like a valid JSON: ', message);
            console.log(e.toString());
            return;
        }
        //console.log("Message received:", data)
        var waitingDiv = instance.krpanoEmbeded.find("#msg-welcome-slave");
        var alreadyAccepted = (!(waitingDiv && waitingDiv.find(".welcome_message").length > 0));
        instance.reactOnAction(data, alreadyAccepted);

        // Handle dollhouse events
        // and pass some pano events to dollhouse 
        var passToDollhouse = [
            'CHANGE_SCENES'
        ];

        if (
            window._DollHouse && typeof(data.type) === 'string' && 
            (data.type.substring(0, 10) === 'DOLLHOUSE_' || ~passToDollhouse.indexOf(data.type))
        ) {
            window._DollHouse.handleLiveEvent(data.type, data);
        }
    };

    this.comunication.subSocket = atmosphere.subscribe(this.comunication.request);

    if (jsonData.playerMode === 'LIVE_MASTER' || jsonData.playerMode === 'LIVE_SLAVE' && $(document).innerWidth() > 768){
        setTimeout(function () {
            var buttons = { 'LIVE_MASTER': '#live-user-list-btn', 'LIVE_SLAVE': '#contact-btn' };
            instance.openMenu('live-user-list-btn');
            if(jsonData.editorTheme !== 'IMMOVIEWER_DEFAULT') {$(buttons[jsonData.playerMode]).addClass('active-button')};
        }, 0)
    }

    console.log("Participant type " + jsonData.playerMode + " subscribed");
}

// Execute actions which arrive from the websocket
LiveConsumer.prototype.reactOnAction = function(data, alreadyAccepted){
    var instance = this;
    var isMaster = jsonData.playerMode === "LIVE_MASTER";
    var enterDefault = true;
    console.log("Received message", data);
    if(data.conferenceRoomID  && data.conferenceRoomID.length > 0){
        var conferenceRoomBlock=this.krpanoEmbeded.find("#phone-code");
        conferenceRoomBlock.find(".code").text(data.conferenceRoomID);
        conferenceRoomBlock.show();
    }
    if (!data.type || data.suspend) {
        //This is the response to the JOIN message. It does not come from any other participant,
        //but directly from the server
        if (data.suspend) {
            //When the server answers with some error, redirect to a page
            location.href = "/portal/guest?error=" + data.error;
            return true;
        } else {
            if (!data.masterPresent) {
                //When master is not present show a waiting message
                this.krpanoEmbeded.find("#live-no-master").modal("show");
            }
            this.masterPresent = data.masterPresent;
            if (data.participants && data.participants.length > 0) {
                var list = data.participants;
                for (var p in list) {
                    if (list.hasOwnProperty(p)) {
                        this.checkIfMaster(list[p]);
                        this.menu.addParticipantInteraction(list[p])
                    }
                }
            }
            return true;
        }
    } else {
        switch (data.type) {
            case 'JOIN':
                //if (alreadyAccepted && (jsonData.playerMode === 'LIVE_SLAVE')) instance.menu.hideMenu();
                console.log("new user entered with name: " + data.participant.contact.firstName + " and userAgent=" + data.participant.userAgent + " and color=" + data.participant.color + " and source=" + data.participant.participantType);
                this.checkIfMaster(data.participant);
                this.menu.addParticipantInteraction(data.participant);

                if (jsonData.playerMode === 'LIVE_SLAVE' && jsonData.email === data.participant.contact.contactEMail && jsonData.promptPrivacyPolicy) {
                    $('#welcome-window').modal('show');
                }

                // if (jsonData.email === data.participant.contact.contactEMail) {
                //     this.conference.checkBrowserSupport(data);
                // }
                return true;

            case 'FORCE_EXIT':
                if(jsonData.playerMode === 'LIVE_SLAVE' && data.participant.participantType === 'LIVE_MASTER'){
                    location.href = "/portal/guest?error=SESSION_FINISHED";
                }
                return true;
            case 'FORCE_EXIT_EXTERNAL':
                this.producer.exitAndSendExit("/");
                return true;
            case 'ONDEMAND_DENIED_RESPONSE':
                if (jsonData.playerMode === 'LIVE_SLAVE') {
                    location.href = jsonData.urls.backendUrls.exitUrl;
                }
                return true;
            case 'CHANGE_ONLINE_VIEWING':
                if (!this.masterPresent) {
                    location.href = data.url;
                }
                return true;
            case 'EXIT':
                console.log("new user leaved with name: " + data.participant.contact.firstName + " and userAgent=" + data.participant.userAgent + " and color=" + data.participant.color + " and source=" + data.participant.participantType);
                var kicked = jsonData.participants[data.participant.contact.contactEMail].kicked || false;
                jsonData.participants[data.participant.contact.contactEMail] = null;

                // this.conference.onCallEnded({ origin: data.participant.contact.contactEMail });
                //this.krpanoEmbeded.find('.mute-audio').removeClass('mute');
                if (data.participant.participantType === 'LIVE_MASTER' && jsonData.playerMode === 'LIVE_SLAVE') {
                    this.masterPresent = false;
                    this.krpanoEmbeded.find("#live-no-master").modal("show");
                } else if (data.participant.participantType === 'LIVE_SLAVE' && jsonData.playerMode === 'LIVE_MASTER') {
                    this.menu.removeParticipant(data.participant);
                    if (!kicked) { this.menu.showSendVisitModal(data.participant); }
                    this.krpanoEmbeded.find(".live-user-list-wrapper .live-user-wrapper:visible:first").click();
                }
                return true;
            case 'SWITCH_ROLES':
                this.menu.switchRoles(data);
               
                return true;
            case 'KICK_PARTICIPANT':
                if (data.participant.participantType === 'LIVE_MASTER' && jsonData.playerMode === 'LIVE_SLAVE' && jsonData.email === data.destination) {
                    location.href = "/portal/guest?error=SESSION_FINISHED";
                } else {
                    jsonData.participants[data.destination].kicked = true;
                }
                return true;
            case 'OPEN_INFOPOINT':
                if (jsonData.playerMode === 'LIVE_SLAVE'){
                   if(!data.infoPoint.toClose) {
                        instance.infopoint.appendDataToInfopointModal(data.infoPoint.name, data.infoPoint.description, data.infoPoint.url, data.infoPoint.type, data.infoPoint.uniqueId)
                   } else {
                        $(data.infoPoint.id).modal('hide');
                   }

                }
                return true;
            case 'INFOPOINT_FULLSCREEN':
                if (jsonData.playerMode === 'LIVE_SLAVE'){
                    console.log(data);
                    this.showInfoPointFullScreen(data);
                }
                return true;
            case 'MAP_EXPAND':
                if (jsonData.playerMode === 'LIVE_SLAVE' && data.participant.participantType === 'LIVE_MASTER') {
                    instance.floorplan.expandFloorplanLive(data.visible === 'SHOW');
                }
                return true;
            default:
                enterDefault=false;
                break;
        }
        if (alreadyAccepted) {
            switch (data.type) {
                case 'SEND_FILE':
                    if (data.participant.participantType != jsonData.playerMode && jsonData.playerMode != 'LIVE_BACKMONITOR') {
                        this.menu.receiverChat(data, true);
                    }
                    return true;
                case 'CHAT_MESSAGE':
                    if (data.participant.participantType != jsonData.playerMode && jsonData.playerMode != 'LIVE_BACKMONITOR') {
                        this.menu.receiverChat(data);
                    }

                    if ( data.participant.participantType === 'LIVE_MASTER' && !$('#contact-btn, #live-user-list-btn').hasClass('active-button') ) {
                        jsonData.editorTheme === 'IMMOVIEWER_DEFAULT' ? this.menu.toggleUnreadMessageBadge('#live-user-list-btn')
                                                                      : this.menu.toggleUnreadMessageBadge('#contact-btn');

                    } else if( data.participant.participantType === 'LIVE_SLAVE' && !$('#live-user-list-btn').hasClass('active-button') ){
                        this.menu.toggleUnreadMessageBadge('#live-user-list-btn');
                    }

                    return true;
                case 'CHANGE_POS':
                    this.svgMouseRemove(null);
                    if (this.producer.allowChangeScene) {
                        return;
                    }

                    // if you lead session OR if someone leads session, do not react on changes
                    var switched = this.producer.switchedRole ? jsonData.email : this.menu.switchedRoleParticipant();
                    if (data.origin === jsonData.email || (switched && data.origin !== switched)) {
                        return;
                    }
                    if (jsonData.participants[data.origin] && jsonData.participants[data.origin].switchedRole) {
                        this.producer.reactOnMasterChange(data);
                    } else if (data.participant.participantType === 'LIVE_MASTER' && jsonData.playerMode === 'LIVE_SLAVE') {
                        this.producer.reactOnMasterChange(data);
                    } else if (data.participant.participantType === 'LIVE_SLAVE' && jsonData.playerMode === 'LIVE_BACKMONITOR'){
                        this.producer.reactOnMasterChange(data);
                    } else if (data.participant.participantType === 'LIVE_SLAVE' && jsonData.playerMode === 'LIVE_MASTER') {
                        this.producer.reactOnSlaveChange(data);
                    }
                    return true;
                case 'INIT_POSITION':
                    if (data.participant.participantType === 'LIVE_MASTER' && jsonData.playerMode === 'LIVE_SLAVE') {
                        this.producer.reactOnMasterChange(data);
                    } else if (data.participant.participantType === 'LIVE_SLAVE' && jsonData.playerMode === 'LIVE_MASTER') {
                        this.producer.reactOnSlaveChange(data);
                    }
                    return true;
                case 'CLICK':
                    if (data.participant.participantType === 'LIVE_SLAVE' && jsonData.playerMode === 'LIVE_MASTER') {
                        this.producer.reactOnSlaveClick(data)
                    }
                    return true;
                case 'DOUBLE_CLICK':
                    if (data.participant.participantType === 'LIVE_MASTER' && jsonData.playerMode === 'LIVE_SLAVE') {
                        this.producer.reactOnMasterDoubleClick(data);
                    }
                    return true;
                case 'CHANGE_ITEM':
                    if (jsonData.playerMode === 'LIVE_SLAVE' && data.url) {
                        location.href = data.url + "?email=" + jsonData.email + "&hideTerms=true";
                    } else if (jsonData.playerMode === 'LIVE_MASTER' && data.url) {
                        location.href = data.url;
                    }
                    return true;
                case 'CHANGE_SCENES':
                    if (data.participant.participantType === 'LIVE_MASTER' && jsonData.playerMode === 'LIVE_SLAVE' && this.cleanString(jsonData.email) === data.destination) {
                        this.producer.allowChangeScene = (data.visible === 'SHOW');
                        var text = window.lang.translate("live.info.message.change_scene.slave." + data.visible);
                        this.menu.showInfo(text, 4000);
                        this.krpano.set("control.usercontrol", this.producer.allowChangeScene ? "all" : "off");
                    }
                    actionExecuted=true;
                    break;
            //     case 'PHONE_CALL':
            //         if (data.participant.participantType != jsonData.playerMode && jsonData.playerMode != 'LIVE_BACKMONITOR' && jsonData.email === data.destination) {
            //             this.conference.onCallReceived(data);
            //         }
            //         return true;
            //    case 'PHONE_ANSWER':
            //        if (data.participant.participantType != jsonData.playerMode && jsonData.playerMode != 'LIVE_BACKMONITOR' && jsonData.email === data.destination) {
            //            this.conference.onCallAnswered(data);
            //        }
            //        return true;
            //     case 'PHONE_LEAVE':
            //         if (data.participant.participantType != jsonData.playerMode && jsonData.playerMode != 'LIVE_BACKMONITOR' && jsonData.email === data.destination) {
            //             this.conference.onCallEnded(data);
            //         }
            //         return true;
            //     case 'PHONE_REJECT':
            //         if (data.participant.participantType != jsonData.playerMode && jsonData.playerMode != 'LIVE_BACKMONITOR' && jsonData.email === data.destination) {
            //             this.conference.onCallRejeted(data);
            //         }
            //         return true;
            //     case 'PHONE_NOT_SUPPORTED':
            //         if (data.participant.participantType === 'LIVE_SLAVE' && jsonData.playerMode === 'LIVE_MASTER') {
            //             this.conference.showNotSupportedLabel(data);
            //         }
            //         return true;
                default:
                    return false;
            }
        }
    }

    //Handle the rest of the events in the specific class (this is the superClass)
    return enterDefault;
}

LiveConsumer.prototype.checkIfMaster = function(participant){
    if (participant.participantType === 'LIVE_MASTER' && jsonData.playerMode === 'LIVE_SLAVE') {
        this.masterPresent = true;
    }
}

LiveConsumer.prototype.showInfoPointFullScreen = function(data) {
    var modal = this.krpanoEmbeded.find('.infpoint-popup[data-unique-name="' + data.infoPoint.uniqueName + '"]')
    modal.find('.fullscreen-wrapper').toggleClass('active', data.visible === 'SHOW');
    modal.toggleClass('active', data.visible === 'SHOW');

    this.infopoint.toggleInfopointModalFullScreen(modal);
}

LiveConsumer.prototype.openMenu = function(element) {
    var activeSection = '#' + $('#' + element).data('open');
    var activePage = this.krpanoEmbeded.find(activeSection);

    if (!$(this).hasClass('active-button')) {
        $('.toggle-right-menu').removeClass('active-button');
        $(this).addClass('active-button');
        $('.contact-information-section, .infopoints-expose-section').addClass('hidden');
    } else  {
        $('.toggle-right-menu').removeClass('active-button');
        $('.contact-information-section, .infopoints-expose-section').removeClass('hidden');
    }

    if (activePage.hasClass('hidden')) {
        activePage.removeClass('hidden')
    } else {
        this.krpanoEmbeded.find(activeSection).toggle("slide", { direction: 'right' });
    }
    $('.right-menu:not('+activeSection+'), .immoview-default:not('+activeSection+')').toggle(false).removeClass('hidden');
}

/** krpano-content/krpano-wrapper-style/js/live/live_producer.js **/
'use strict';
var LiveProducer = function(krpanoEmbeded, krpano, api, detectedEvent, comunication) {
    this.krpanoEmbeded = krpanoEmbeded;
    this.krpano = krpano;
    this.api = api;
    this.detectedEvent = detectedEvent;
    this.comunication = comunication;
    this.allowChangeScene = (jsonData.playerMode === "LIVE_MASTER");
    this.switchedRole = false;
    this.hideClickMarkerDelay = 1500;
    CommonPlayer.call(this, krpanoEmbeded);

};

LiveProducer.prototype = Object.create(CommonPlayer.prototype);
LiveProducer.prototype.constructor = LiveProducer;

LiveProducer.prototype.initUsersControlPanel = function(){
    var userPanel = this.krpanoEmbeded.find(".live-user-control-panel-wrapper");
    console.log("Here userPanel=", userPanel);
    this.userScenesInteractionCallback(userPanel);
    this.userKickCallback(userPanel);
    this.listenToDblClick();
}

LiveProducer.prototype.userScenesInteractionCallback = function(wrapper){
    var instance = this;
    $('.live-user-list-container').on(this.detectedEvent, '.live-pointer-btn', function(e) {
        e.preventDefault();
        e.stopPropagation();
        $(this).find('.opened-access, .closed-access').toggleClass('hidden');
        instance.sendScenesInteraction($(this));
    });
}
LiveProducer.prototype.userKickCallback = function(wrapper){
    var instance = this;
    this.krpanoEmbeded.find("#live-remove-participant").on(this.detectedEvent, '#remove-participant-btn', function(e) {
        e.preventDefault();
        var modal = $(this).closest("#live-remove-participant");
        instance.sendKick(modal.attr("destination"));
        modal.modal('hide');
    });
}
/************************************** Sending messages **************************************/
LiveProducer.prototype.sendPosition = function () {
    var instance = this;
    var follow = this.krpanoEmbeded.find("#follow-guest-interaction");
    if (!(follow && follow.length > 0 && follow.is(':checked'))) {
        var data = {
            playerWidth: instance.krpanoEmbeded.width(),
            playerHeight: instance.krpanoEmbeded.height()
        };
        this.comunication.sendPositionCommon(data, null, false);
    }
};

//Send kick participant to the websocket
//elem = elem from where the master clicked "kick participant".
LiveProducer.prototype.sendKick = function(destination) {
    var instance = this;
    var json = atmosphere.util.stringifyJSON({
        roomType: instance.comunication.roomType,
        type: "KICK_PARTICIPANT",
        destination: destination
    });
    console.log("Sending KICK_PARTICIPANT message to the server= " + json);
    this.comunication.subSocket.push(json);
    return false;
}

//Send to the websocket a message telling a participant that it is allowed/not allowed to change scenes
//elem = the elem the master ahs clicked to perform this action
LiveProducer.prototype.sendScenesInteraction = function(elem) {
    var show = !jsonData.participants[elem.attr("data-email")].allowChangeScene;
    var instance = this;
    var json = atmosphere.util.stringifyJSON({
        roomType: instance.comunication.roomType,
        type: "CHANGE_SCENES",
        visible: show ? "SHOW" : "HIDE",
        destination: elem.attr("data-id")
    });
    console.log("Sending CHANGE_SCENES message to the server= " + json);
    this.comunication.subSocket.push(json);

    jsonData.participants[elem.attr("data-email")].allowChangeScene = show;
    var potentialBuyerWrapper = this.krpanoEmbeded.find('#' + elem.attr("data-id"));
    var user_name = potentialBuyerWrapper.find(".live-user-name").text();
    var text=window.lang.translate("live.info.message.change_scene.master." + show).replace("{0}", user_name);
    this.showInfo(text, 4000);
    return false;
}


//Send exit message to the websocket and exit redirect to the exit page on the client too.
//elem = elem from where the master clicked exit.
//otherUrl = alternative exit URL.
LiveProducer.prototype.exitAndSendExit = function(url){
    var instance = this;
    var json = atmosphere.util.stringifyJSON({
        roomType: instance.roomType,
        type: "FORCE_EXIT"
    });
    this.comunication.subSocket.push(json);
    location.href = url;
}


//Change point of view. This method is executed in the slave side, when the master pulls the slave to a certain position.
LiveProducer.prototype.reactOnMasterChange = function(data){
    this.reactOnPosOrRoomChange(data);
}

LiveProducer.prototype.reactOnPosOrRoomChange = function(data){
    var instance = this;
    if (data.scene && data.scene !== this.krpano.get("xml.scene")) {
        //loadscene is a global function for krpano
        var scene = data.scene.replace("scene", "");
        var fileName = instance.originalFilename(scene);
        this.krpano.call("plugin[Immoviewer].loadscene('"+fileName+"');");
        this.updateLookatMainView(data, false);
    } else if (data.vlookat && data.hlookat && data.fov) {
        this.updateLookatMainView(data, false);
    }
}

// Update the point of view for the main window virtual tour
// data = new point of view
// instant = boolean which tells the function if the point of view should change inmidiately or in smoothly.
LiveProducer.prototype.updateLookatMainView = function(data, instant){
    if (instant) {
        this.krpano.set("view.vlookat", data.vlookat);
        this.krpano.set("view.hlookat", data.hlookat);
        this.krpano.set("view.fov", data.fov);
    } else {
        this.krpano.call("tween('view.vlookat', " + data.vlookat + ")");
        this.krpano.call("tween('view.hlookat', " + data.hlookat + ")");
        this.krpano.call("tween('view.fov', " + data.fov + ")");
    }
}
LiveProducer.prototype.getAppropriateBackMonitorWidth = function(data) {
    var bmWidth       = 300;
    var currentWidth  = this.krpano.get("stagewidth");
    var pageOrientation = data.playerWidth > data.playerHeight ? 'landscape' : 'portrait';

    if (currentWidth < 768) {
        return false;
    }

    switch (pageOrientation) {
        case 'landscape':
            if (currentWidth >= 1568) {
                bmWidth = 450;
            } else if (currentWidth < 1568 && currentWidth > 1024) {
                bmWidth = 400;
            }
            break;
        case 'portrait':
            if (currentWidth < 1568 && currentWidth > 1024) {
                bmWidth = 250;
            } else if (currentWidth <= 1024) {
                bmWidth = 200;
            }
            break;
    }

    return bmWidth;
}
//Changing resolution of back monitor window when needed (when the slave changes its resolution).
LiveProducer.prototype.reactOnSlaveResolutionChange = function(data){
    var maxWidth = this.getAppropriateBackMonitorWidth(data);

    if (data.playerWidth && data.playerHeight && data.participant.participantType === 'LIVE_SLAVE' && maxWidth) {
        var backChannelWidth = data.playerWidth;
        var backChannelHeight = data.playerHeight;
        if (backChannelWidth > maxWidth) {
            var factor = maxWidth / backChannelWidth;
            backChannelWidth = data.playerWidth * factor;
            backChannelHeight = data.playerHeight * factor;
        }
        var backChannelDiv = $('.live-follow-guest-interaction');
        backChannelDiv.width(backChannelWidth);
        // backChannelDiv.height(backChannelHeight + 40);

        //Adjusting the wrapper to the right place
        /*
        var wrapWrapper = backChannelDiv.parent().parent().parent().parent().parent().parent();
        if (wrapWrapper.hasClass("bottom")) {
            var finalY = -wrapWrapper.outerHeight() + backChannelHeight + 12 + 64;
            $(".panoBackChannelWrapper.bottom").css({
                "bottom": finalY + "px"
            });
        }
        */
        this.oldWidth = data.playerWidth;
        this.oldHeight = data.playerHeight;

        //Also set the resolution in the monitor
        this.changeResolutionOnPreview(data);
    }
}
LiveProducer.prototype.reactOnSlaveChange = function(data){
    if (data.playerWidth && data.playerHeight &&
        (data.playerWidth !== this.oldWidth || data.playerHeight !== this.oldHeight)) {
        this.reactOnSlaveResolutionChange(data);
    }

    var follow = $("#follow-guest-interaction");
    if (follow && follow.length > 0 && follow.is(':checked')) {
        this.reactOnPosOrRoomChange(data, false);
    }

    //If the message is init, change also resolution
    if (data.type == 'INIT_POSITION') {
        this.changeResolutionOnPreview(data);
    }
}

//Change the resolution description on the back monitor window. This method is executed in the master side, when the slaves changes the resolution.
LiveProducer.prototype.changeResolutionOnPreview = function(data){
    if (data.playerWidth && data.playerHeight) {
        var small = this.krpanoEmbeded.find("#preview-resolution");
        if (small && small.length) {
            small.text(data.playerWidth + "x" + data.playerHeight);
        }
    }
}

//Change scene of the preview monitor. This method is executed in the master side, when the slave changes the room.
/*
LiveProducer.prototype.previewWindowOnLoadScene = function(data){
    if (data.scene && data.scene !== this.backChannel.get("xml.scene")) {
        var follow = $("#follow-guest-interaction");
        if (follow && follow.length > 0 && follow.is(':checked')) {
            var scene = data.scene.replace("scene", "");
            this.krpano.call("plugin[Immoviewer].loadscene('"+scene+"');");
            this.updateLookatMainView(data, true);
        }
        this.backChannel.call("loadscene(" + data.scene + ", null, MERGE, ZOOMBLEND(1.2)); lookat(" + data.hlookat + "," + data.vlookat + "); wait(BLEND);");
        this.updateLookat(data, true);
    }
}
*/
// Update the point of view for the back monitor virtual tour
// data = new point of view
// instant = boolean which tells the function if the point of view should change inmidiately or in smoothly.
/*
LiveProducer.prototype.updateLookat = function(data, instant){
    if (!isNaN(data.vlookat) && 90 && !isNaN(data.hlookat) && data.fov > 0) {
        if (instant) {
            this.backChannel.set("view.vlookat", data.vlookat);
            this.backChannel.set("view.hlookat", data.hlookat);
            this.backChannel.set("view.fov", data.fov);
        } else {
            this.backChannel.call("tween('view.vlookat', " + data.vlookat + ")");
            this.backChannel.call("tween('view.hlookat', " + data.hlookat + ")");
            this.backChannel.call("tween('view.fov', " + data.fov + ")");
        }
        var follow = $("#follow-guest-interaction");
        if (follow && follow.length > 0 && follow.is(':checked')) {
            this.updateLookatMainView(data, instant);
        }
    }
}
*/

LiveProducer.prototype.sendClick = function(x, y){
    this.comunication.sendClick(x,y);
}

LiveProducer.prototype.reactOnMasterDoubleClick = function(data){
    if (data.doubleClickH && data.doubleClickV) {
        var clickPos = this.calculateChannelPosFromDegree(data.doubleClickH, data.doubleClickV, this.krpanoEmbeded, this.krpano);
        this.showMouseDivBriefly('mouseDoubleClickDiv', clickPos.x, clickPos.y);
    }
}

//Showing a mouse in the back monitor window. This method is executed in the master side, when the slave double clicks somewhere in the virtual tour.
LiveProducer.prototype.reactOnSlaveClick = function(data){
    if (this.backChannel && data.clickH && data.clickV) {
        var clickPos = this.calculateChannelPosFromDegree(data.clickH, data.clickV, $("#panoBackChannelObject"), this.backChannel);
        var offset = 10;
        this.showMouseDivBriefly('mouseClickDiv', clickPos.x + offset, clickPos.y + offset);
    }
}


LiveProducer.prototype.listenToDblClick = function() {
    var instance = this;
    this.krpanoEmbeded.on('dblclick', function(event){
        var pos    = instance.krpano.screentosphere(event.clientX, event.clientY);
        var player = $("#VIRTUAL_TOUR_container");
        var data   = {
            playerWidth: player.width(),
            playerHeight: player.height()
        };
        instance.sendClick(data, pos.x, pos.y)
        instance.showMouseDivBriefly('mouseDoubleClickDiv', event.clientX, event.clientY);
    });
}


// Show a div in the desired position and hide after "hideClickMarkerDelay" time (in ms)
// divName = The div we want to show
// posX = The x axis position where we want to show the div divName
// posY = The y axis position where we want to show the div divName
// color = The color we want to give to the div
LiveProducer.prototype.showMouseDivBriefly = function(divName, posX, posY, color){
    var div = this.showMouseDiv(divName, posX, posY, color);
    var hideClickMarkerDelay = this.hideClickMarkerDelay;
    setTimeout(function() {
        div.hide();
    }, hideClickMarkerDelay);
}

//PRIVATE METHODS -----------------------------------------------------------------------------------
// Show a div in the desired position
// divName = The div we want to show
// posX = The x axis position where we want to show the div divName
// posY = The y axis position where we want to show the div divName
// color = The color we want to give to the div
LiveProducer.prototype.showMouseDiv = function(divName, posX, posY, color){
    var div = $("#" + divName);
    div.css({
        "left": (posX - 20) + "px",
        "top": (posY - 16) + "px"
    });
    if (color) {
        div.children().first().css({
            "color": color
        });
    }
    div.show();
    return div;
}

LiveProducer.prototype.sendCustomEvent = function (event) {
    console.log('sendCustomEvent', event)
    
    if (typeof(event.type) === 'string' && typeof(event.data) === 'object') {
        if (this.comunication && this.comunication.subSocket) {
            var assignedData = Object.assign({type: event.type}, event.data);
            assignedData.roomType = 'VIRTUAL_TOUR';
            var message = atmosphere.util.stringifyJSON(assignedData);
            this.comunication.subSocket.push(message);
        }
    } else {
        console.error('Event not match pattern! Need contain string "type" and object "data".', event);
    }
}